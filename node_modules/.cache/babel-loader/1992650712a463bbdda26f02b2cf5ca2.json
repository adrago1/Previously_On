{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getFileModifiedMap = getFileModifiedMap;\nexports.createContext = createContext;\nexports.getContext = getContext;\n\nvar _fs = _interopRequireDefault(require(\"fs\"));\n\nvar _url = _interopRequireDefault(require(\"url\"));\n\nvar _postcss = _interopRequireDefault(require(\"postcss\"));\n\nvar _dlv = _interopRequireDefault(require(\"dlv\"));\n\nvar _postcssSelectorParser = _interopRequireDefault(require(\"postcss-selector-parser\"));\n\nvar _transformThemeValue = _interopRequireDefault(require(\"../../util/transformThemeValue\"));\n\nvar _parseObjectStyles = _interopRequireDefault(require(\"../../util/parseObjectStyles\"));\n\nvar _prefixSelector = _interopRequireDefault(require(\"../../util/prefixSelector\"));\n\nvar _isPlainObject = _interopRequireDefault(require(\"../../util/isPlainObject\"));\n\nvar _escapeClassName = _interopRequireDefault(require(\"../../util/escapeClassName\"));\n\nvar _nameClass = _interopRequireDefault(require(\"../../util/nameClass\"));\n\nvar _pluginUtils = require(\"../../util/pluginUtils\");\n\nvar _bigSign = _interopRequireDefault(require(\"../../util/bigSign\"));\n\nvar _corePlugins = _interopRequireDefault(require(\"../corePlugins\"));\n\nvar sharedState = _interopRequireWildcard(require(\"./sharedState\"));\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction toPath(value) {\n  if (Array.isArray(value)) {\n    return value;\n  }\n\n  let inBrackets = false;\n  let parts = [];\n  let chunk = '';\n\n  for (let i = 0; i < value.length; i++) {\n    let char = value[i];\n\n    if (char === '[') {\n      inBrackets = true;\n      parts.push(chunk);\n      chunk = '';\n      continue;\n    }\n\n    if (char === ']' && inBrackets) {\n      inBrackets = false;\n      parts.push(chunk);\n      chunk = '';\n      continue;\n    }\n\n    if (char === '.' && !inBrackets && chunk.length > 0) {\n      parts.push(chunk);\n      chunk = '';\n      continue;\n    }\n\n    chunk = chunk + char;\n  }\n\n  if (chunk.length > 0) {\n    parts.push(chunk);\n  }\n\n  return parts;\n}\n\nfunction insertInto(list, value, {\n  before = []\n} = {}) {\n  before = [].concat(before);\n\n  if (before.length <= 0) {\n    list.push(value);\n    return;\n  }\n\n  let idx = list.length - 1;\n\n  for (let other of before) {\n    let iidx = list.indexOf(other);\n    if (iidx === -1) continue;\n    idx = Math.min(idx, iidx);\n  }\n\n  list.splice(idx, 0, value);\n}\n\nfunction parseStyles(styles) {\n  if (!Array.isArray(styles)) {\n    return parseStyles([styles]);\n  }\n\n  return styles.flatMap(style => {\n    let isNode = !Array.isArray(style) && !(0, _isPlainObject.default)(style);\n    return isNode ? style : (0, _parseObjectStyles.default)(style);\n  });\n}\n\nfunction getClasses(selector) {\n  let parser = (0, _postcssSelectorParser.default)(selectors => {\n    let allClasses = [];\n    selectors.walkClasses(classNode => {\n      allClasses.push(classNode.value);\n    });\n    return allClasses;\n  });\n  return parser.transformSync(selector);\n}\n\nfunction extractCandidates(node) {\n  let classes = node.type === 'rule' ? getClasses(node.selector) : [];\n\n  if (node.type === 'atrule') {\n    node.walkRules(rule => {\n      classes = [...classes, ...getClasses(rule.selector)];\n    });\n  }\n\n  return classes;\n}\n\nfunction withIdentifiers(styles) {\n  return parseStyles(styles).flatMap(node => {\n    let nodeMap = new Map();\n    let candidates = extractCandidates(node); // If this isn't \"on-demandable\", assign it a universal candidate.\n\n    if (candidates.length === 0) {\n      return [['*', node]];\n    }\n\n    return candidates.map(c => {\n      if (!nodeMap.has(node)) {\n        nodeMap.set(node, node);\n      }\n\n      return [c, nodeMap.get(node)];\n    });\n  });\n}\n\nlet matchingBrackets = new Map([['{', '}'], ['[', ']'], ['(', ')']]);\nlet inverseMatchingBrackets = new Map(Array.from(matchingBrackets.entries()).map(([k, v]) => [v, k]));\nlet quotes = new Set(['\"', \"'\", '`']); // Arbitrary values must contain balanced brackets (), [] and {}. Escaped\n// values don't count, and brackets inside quotes also don't count.\n//\n// E.g.: w-[this-is]w-[weird-and-invalid]\n// E.g.: w-[this-is\\\\]w-\\\\[weird-but-valid]\n// E.g.: content-['this-is-also-valid]-weirdly-enough']\n\nfunction isValidArbitraryValue(value) {\n  let stack = [];\n  let inQuotes = false;\n\n  for (let i = 0; i < value.length; i++) {\n    let char = value[i]; // Non-escaped quotes allow us to \"allow\" anything in between\n\n    if (quotes.has(char) && value[i - 1] !== '\\\\') {\n      inQuotes = !inQuotes;\n    }\n\n    if (inQuotes) continue;\n    if (value[i - 1] === '\\\\') continue; // Escaped\n\n    if (matchingBrackets.has(char)) {\n      stack.push(char);\n    } else if (inverseMatchingBrackets.has(char)) {\n      let inverse = inverseMatchingBrackets.get(char); // Nothing to pop from, therefore it is unbalanced\n\n      if (stack.length <= 0) {\n        return false;\n      } // Popped value must match the inverse value, otherwise it is unbalanced\n\n\n      if (stack.pop() !== inverse) {\n        return false;\n      }\n    }\n  } // If there is still something on the stack, it is also unbalanced\n\n\n  if (stack.length > 0) {\n    return false;\n  } // All good, totally balanced!\n\n\n  return true;\n}\n\nfunction buildPluginApi(tailwindConfig, context, {\n  variantList,\n  variantMap,\n  offsets\n}) {\n  function getConfigValue(path, defaultValue) {\n    return path ? (0, _dlv.default)(tailwindConfig, path, defaultValue) : tailwindConfig;\n  }\n\n  function applyConfiguredPrefix(selector) {\n    return (0, _prefixSelector.default)(tailwindConfig.prefix, selector);\n  }\n\n  function prefixIdentifier(identifier, options) {\n    if (identifier === '*') {\n      return '*';\n    }\n\n    if (!options.respectPrefix) {\n      return identifier;\n    }\n\n    if (typeof context.tailwindConfig.prefix === 'function') {\n      return (0, _prefixSelector.default)(context.tailwindConfig.prefix, `.${identifier}`).substr(1);\n    }\n\n    return context.tailwindConfig.prefix + identifier;\n  }\n\n  return {\n    addVariant(variantName, variantFunctions, options = {}) {\n      variantFunctions = [].concat(variantFunctions);\n      insertInto(variantList, variantName, options);\n      variantMap.set(variantName, variantFunctions);\n    },\n\n    postcss: _postcss.default,\n    prefix: applyConfiguredPrefix,\n    e: _escapeClassName.default,\n    config: getConfigValue,\n\n    theme(path, defaultValue) {\n      const [pathRoot, ...subPaths] = toPath(path);\n      const value = getConfigValue(['theme', pathRoot, ...subPaths], defaultValue);\n      return (0, _transformThemeValue.default)(pathRoot)(value);\n    },\n\n    corePlugins: path => {\n      if (Array.isArray(tailwindConfig.corePlugins)) {\n        return tailwindConfig.corePlugins.includes(path);\n      }\n\n      return getConfigValue(['corePlugins', path], true);\n    },\n    variants: (path, defaultValue) => {\n      if (Array.isArray(tailwindConfig.variants)) {\n        return tailwindConfig.variants;\n      }\n\n      return getConfigValue(['variants', path], defaultValue);\n    },\n\n    addBase(base) {\n      for (let [identifier, rule] of withIdentifiers(base)) {\n        let prefixedIdentifier = prefixIdentifier(identifier, {});\n        let offset = offsets.base++;\n\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n\n        context.candidateRuleMap.get(prefixedIdentifier).push([{\n          sort: offset,\n          layer: 'base'\n        }, rule]);\n      }\n    },\n\n    addComponents(components, options) {\n      let defaultOptions = {\n        variants: [],\n        respectPrefix: true,\n        respectImportant: false,\n        respectVariants: true\n      };\n      options = Object.assign({}, defaultOptions, Array.isArray(options) ? {\n        variants: options\n      } : options);\n\n      for (let [identifier, rule] of withIdentifiers(components)) {\n        let prefixedIdentifier = prefixIdentifier(identifier, options);\n        let offset = offsets.components++;\n\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n\n        context.candidateRuleMap.get(prefixedIdentifier).push([{\n          sort: offset,\n          layer: 'components',\n          options\n        }, rule]);\n      }\n    },\n\n    addUtilities(utilities, options) {\n      let defaultOptions = {\n        variants: [],\n        respectPrefix: true,\n        respectImportant: true,\n        respectVariants: true\n      };\n      options = Object.assign({}, defaultOptions, Array.isArray(options) ? {\n        variants: options\n      } : options);\n\n      for (let [identifier, rule] of withIdentifiers(utilities)) {\n        let prefixedIdentifier = prefixIdentifier(identifier, options);\n        let offset = offsets.utilities++;\n\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n\n        context.candidateRuleMap.get(prefixedIdentifier).push([{\n          sort: offset,\n          layer: 'utilities',\n          options\n        }, rule]);\n      }\n    },\n\n    matchUtilities: function (utilities, options) {\n      let defaultOptions = {\n        variants: [],\n        respectPrefix: true,\n        respectImportant: true,\n        respectVariants: true\n      };\n      options = { ...defaultOptions,\n        ...options\n      };\n      let offset = offsets.utilities++;\n\n      for (let identifier in utilities) {\n        let prefixedIdentifier = prefixIdentifier(identifier, options);\n        let rule = utilities[identifier];\n\n        function wrapped(modifier) {\n          let {\n            type = 'any'\n          } = options;\n          type = [].concat(type);\n          let [value, coercedType] = (0, _pluginUtils.coerceValue)(type, modifier, options.values, tailwindConfig);\n\n          if (!type.includes(coercedType) || value === undefined) {\n            return [];\n          }\n\n          if (!isValidArbitraryValue(value)) {\n            return [];\n          }\n\n          let includedRules = [];\n          let ruleSets = [].concat(rule(value, {\n            includeRules(rules) {\n              includedRules.push(...rules);\n            }\n\n          })).filter(Boolean).map(declaration => ({\n            [(0, _nameClass.default)(identifier, modifier)]: declaration\n          }));\n          return [...includedRules, ...ruleSets];\n        }\n\n        let withOffsets = [{\n          sort: offset,\n          layer: 'utilities',\n          options\n        }, wrapped];\n\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n\n        context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);\n      }\n    }\n  };\n}\n\nlet fileModifiedMapCache = new WeakMap();\n\nfunction getFileModifiedMap(context) {\n  if (!fileModifiedMapCache.has(context)) {\n    fileModifiedMapCache.set(context, new Map());\n  }\n\n  return fileModifiedMapCache.get(context);\n}\n\nfunction trackModified(files, fileModifiedMap) {\n  let changed = false;\n\n  for (let file of files) {\n    if (!file) continue;\n\n    let parsed = _url.default.parse(file);\n\n    let pathname = parsed.hash ? parsed.href.replace(parsed.hash, '') : parsed.href;\n    pathname = parsed.search ? pathname.replace(parsed.search, '') : pathname;\n\n    let newModified = _fs.default.statSync(decodeURIComponent(pathname)).mtimeMs;\n\n    if (!fileModifiedMap.has(file) || newModified > fileModifiedMap.get(file)) {\n      changed = true;\n    }\n\n    fileModifiedMap.set(file, newModified);\n  }\n\n  return changed;\n}\n\nfunction extractVariantAtRules(node) {\n  node.walkAtRules(atRule => {\n    if (['responsive', 'variants'].includes(atRule.name)) {\n      extractVariantAtRules(atRule);\n      atRule.before(atRule.nodes);\n      atRule.remove();\n    }\n  });\n}\n\nfunction collectLayerPlugins(root) {\n  let layerPlugins = [];\n  root.each(node => {\n    if (node.type === 'atrule' && ['responsive', 'variants'].includes(node.name)) {\n      node.name = 'layer';\n      node.params = 'utilities';\n    }\n  }); // Walk @layer rules and treat them like plugins\n\n  root.walkAtRules('layer', layerRule => {\n    extractVariantAtRules(layerRule);\n\n    if (layerRule.params === 'base') {\n      for (let node of layerRule.nodes) {\n        layerPlugins.push(function ({\n          addBase\n        }) {\n          addBase(node, {\n            respectPrefix: false\n          });\n        });\n      }\n\n      layerRule.remove();\n    } else if (layerRule.params === 'components') {\n      for (let node of layerRule.nodes) {\n        layerPlugins.push(function ({\n          addComponents\n        }) {\n          addComponents(node, {\n            respectPrefix: false\n          });\n        });\n      }\n\n      layerRule.remove();\n    } else if (layerRule.params === 'utilities') {\n      for (let node of layerRule.nodes) {\n        layerPlugins.push(function ({\n          addUtilities\n        }) {\n          addUtilities(node, {\n            respectPrefix: false\n          });\n        });\n      }\n\n      layerRule.remove();\n    }\n  });\n  return layerPlugins;\n}\n\nfunction resolvePlugins(context, tailwindDirectives, root) {\n  let corePluginList = Object.entries(_corePlugins.default).map(([name, plugin]) => {\n    if (!context.tailwindConfig.corePlugins.includes(name)) {\n      return null;\n    }\n\n    return plugin;\n  }).filter(Boolean);\n  let userPlugins = context.tailwindConfig.plugins.map(plugin => {\n    if (plugin.__isOptionsFunction) {\n      plugin = plugin();\n    }\n\n    return typeof plugin === 'function' ? plugin : plugin.handler;\n  });\n  let layerPlugins = collectLayerPlugins(root, tailwindDirectives); // TODO: This is a workaround for backwards compatibility, since custom variants\n  // were historically sorted before screen/stackable variants.\n\n  let beforeVariants = [_corePlugins.default['pseudoElementVariants'], _corePlugins.default['pseudoClassVariants']];\n  let afterVariants = [_corePlugins.default['directionVariants'], _corePlugins.default['reducedMotionVariants'], _corePlugins.default['darkVariants'], _corePlugins.default['screenVariants']];\n  return [...corePluginList, ...beforeVariants, ...userPlugins, ...afterVariants, ...layerPlugins];\n}\n\nfunction registerPlugins(plugins, context) {\n  let variantList = [];\n  let variantMap = new Map();\n  let offsets = {\n    base: 0n,\n    components: 0n,\n    utilities: 0n\n  };\n  let pluginApi = buildPluginApi(context.tailwindConfig, context, {\n    variantList,\n    variantMap,\n    offsets\n  });\n\n  for (let plugin of plugins) {\n    if (Array.isArray(plugin)) {\n      for (let pluginItem of plugin) {\n        pluginItem(pluginApi);\n      }\n    } else {\n      plugin(pluginApi);\n    }\n  }\n\n  let highestOffset = (args => args.reduce((m, e) => e > m ? e : m))([offsets.base, offsets.components, offsets.utilities]);\n\n  let reservedBits = BigInt(highestOffset.toString(2).length);\n  context.layerOrder = {\n    base: 1n << reservedBits << 0n,\n    components: 1n << reservedBits << 1n,\n    utilities: 1n << reservedBits << 2n\n  };\n  reservedBits += 3n;\n  let offset = 0;\n  context.variantOrder = new Map(variantList.map((variant, i) => {\n    let variantFunctions = variantMap.get(variant).length;\n    let bits = 1n << BigInt(i + offset) << reservedBits;\n    offset += variantFunctions - 1;\n    return [variant, bits];\n  }).sort(([, a], [, z]) => (0, _bigSign.default)(a - z)));\n  context.minimumScreen = [...context.variantOrder.values()].shift(); // Build variantMap\n\n  for (let [variantName, variantFunctions] of variantMap.entries()) {\n    let sort = context.variantOrder.get(variantName);\n    context.variantMap.set(variantName, variantFunctions.map((variantFunction, idx) => [sort << BigInt(idx), variantFunction]));\n  }\n}\n\nfunction createContext(tailwindConfig, changedContent = [], tailwindDirectives = new Set(), root = _postcss.default.root()) {\n  let context = {\n    disposables: [],\n    ruleCache: new Set(),\n    classCache: new Map(),\n    applyClassCache: new Map(),\n    notClassCache: new Set(),\n    postCssNodeCache: new Map(),\n    candidateRuleMap: new Map(),\n    tailwindConfig,\n    changedContent: changedContent,\n    variantMap: new Map(),\n    stylesheetCache: null\n  };\n  let resolvedPlugins = resolvePlugins(context, tailwindDirectives, root);\n  registerPlugins(resolvedPlugins, context);\n  return context;\n}\n\nlet contextMap = sharedState.contextMap;\nlet configContextMap = sharedState.configContextMap;\nlet contextSourcesMap = sharedState.contextSourcesMap;\n\nfunction getContext(tailwindDirectives, root, result, tailwindConfig, userConfigPath, tailwindConfigHash, contextDependencies) {\n  let sourcePath = result.opts.from;\n  let isConfigFile = userConfigPath !== null;\n  sharedState.env.DEBUG && console.log('Source path:', sourcePath);\n  let existingContext;\n\n  if (isConfigFile && contextMap.has(sourcePath)) {\n    existingContext = contextMap.get(sourcePath);\n  } else if (configContextMap.has(tailwindConfigHash)) {\n    let context = configContextMap.get(tailwindConfigHash);\n    contextSourcesMap.get(context).add(sourcePath);\n    contextMap.set(sourcePath, context);\n    existingContext = context;\n  } // If there's already a context in the cache and we don't need to\n  // reset the context, return the cached context.\n\n\n  if (existingContext) {\n    let contextDependenciesChanged = trackModified([...contextDependencies], getFileModifiedMap(existingContext));\n\n    if (!contextDependenciesChanged) {\n      return [existingContext, false];\n    }\n  } // If this source is in the context map, get the old context.\n  // Remove this source from the context sources for the old context,\n  // and clean up that context if no one else is using it. This can be\n  // called by many processes in rapid succession, so we check for presence\n  // first because the first process to run this code will wipe it out first.\n\n\n  if (contextMap.has(sourcePath)) {\n    let oldContext = contextMap.get(sourcePath);\n\n    if (contextSourcesMap.has(oldContext)) {\n      contextSourcesMap.get(oldContext).delete(sourcePath);\n\n      if (contextSourcesMap.get(oldContext).size === 0) {\n        contextSourcesMap.delete(oldContext);\n\n        for (let [tailwindConfigHash, context] of configContextMap) {\n          if (context === oldContext) {\n            configContextMap.delete(tailwindConfigHash);\n          }\n        }\n\n        for (let disposable of oldContext.disposables.splice(0)) {\n          disposable(oldContext);\n        }\n      }\n    }\n  }\n\n  sharedState.env.DEBUG && console.log('Setting up new context...');\n  let context = createContext(tailwindConfig, [], tailwindDirectives, root);\n  trackModified([...contextDependencies], getFileModifiedMap(context)); // ---\n  // Update all context tracking state\n\n  configContextMap.set(tailwindConfigHash, context);\n  contextMap.set(sourcePath, context);\n\n  if (!contextSourcesMap.has(context)) {\n    contextSourcesMap.set(context, new Set());\n  }\n\n  contextSourcesMap.get(context).add(sourcePath);\n  return [context, true];\n}","map":{"version":3,"sources":["/home/alan/delivery_2/previously_on/client/node_modules/tailwindcss/lib/jit/lib/setupContextUtils.js"],"names":["Object","defineProperty","exports","value","getFileModifiedMap","createContext","getContext","_fs","_interopRequireDefault","require","_url","_postcss","_dlv","_postcssSelectorParser","_transformThemeValue","_parseObjectStyles","_prefixSelector","_isPlainObject","_escapeClassName","_nameClass","_pluginUtils","_bigSign","_corePlugins","sharedState","_interopRequireWildcard","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","__esModule","default","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","toPath","Array","isArray","inBrackets","parts","chunk","i","length","char","push","insertInto","list","before","concat","idx","other","iidx","indexOf","Math","min","splice","parseStyles","styles","flatMap","style","isNode","getClasses","selector","parser","selectors","allClasses","walkClasses","classNode","transformSync","extractCandidates","node","classes","type","walkRules","rule","withIdentifiers","nodeMap","Map","candidates","map","c","matchingBrackets","inverseMatchingBrackets","from","entries","k","v","quotes","Set","isValidArbitraryValue","stack","inQuotes","inverse","pop","buildPluginApi","tailwindConfig","context","variantList","variantMap","offsets","getConfigValue","path","defaultValue","applyConfiguredPrefix","prefix","prefixIdentifier","identifier","options","respectPrefix","substr","addVariant","variantName","variantFunctions","postcss","e","config","theme","pathRoot","subPaths","corePlugins","includes","variants","addBase","base","prefixedIdentifier","offset","candidateRuleMap","sort","layer","addComponents","components","defaultOptions","respectImportant","respectVariants","assign","addUtilities","utilities","matchUtilities","wrapped","modifier","coercedType","coerceValue","values","undefined","includedRules","ruleSets","includeRules","rules","filter","Boolean","declaration","withOffsets","fileModifiedMapCache","trackModified","files","fileModifiedMap","changed","file","parsed","parse","pathname","hash","href","replace","search","newModified","statSync","decodeURIComponent","mtimeMs","extractVariantAtRules","walkAtRules","atRule","name","nodes","remove","collectLayerPlugins","root","layerPlugins","each","params","layerRule","resolvePlugins","tailwindDirectives","corePluginList","plugin","userPlugins","plugins","__isOptionsFunction","handler","beforeVariants","afterVariants","registerPlugins","pluginApi","pluginItem","highestOffset","args","reduce","m","reservedBits","BigInt","toString","layerOrder","variantOrder","variant","bits","a","z","minimumScreen","shift","variantFunction","changedContent","disposables","ruleCache","classCache","applyClassCache","notClassCache","postCssNodeCache","stylesheetCache","resolvedPlugins","contextMap","configContextMap","contextSourcesMap","result","userConfigPath","tailwindConfigHash","contextDependencies","sourcePath","opts","isConfigFile","env","DEBUG","console","log","existingContext","add","contextDependenciesChanged","oldContext","delete","size","disposable"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getFileModifiedMap = getFileModifiedMap;\nexports.createContext = createContext;\nexports.getContext = getContext;\n\nvar _fs = _interopRequireDefault(require(\"fs\"));\n\nvar _url = _interopRequireDefault(require(\"url\"));\n\nvar _postcss = _interopRequireDefault(require(\"postcss\"));\n\nvar _dlv = _interopRequireDefault(require(\"dlv\"));\n\nvar _postcssSelectorParser = _interopRequireDefault(require(\"postcss-selector-parser\"));\n\nvar _transformThemeValue = _interopRequireDefault(require(\"../../util/transformThemeValue\"));\n\nvar _parseObjectStyles = _interopRequireDefault(require(\"../../util/parseObjectStyles\"));\n\nvar _prefixSelector = _interopRequireDefault(require(\"../../util/prefixSelector\"));\n\nvar _isPlainObject = _interopRequireDefault(require(\"../../util/isPlainObject\"));\n\nvar _escapeClassName = _interopRequireDefault(require(\"../../util/escapeClassName\"));\n\nvar _nameClass = _interopRequireDefault(require(\"../../util/nameClass\"));\n\nvar _pluginUtils = require(\"../../util/pluginUtils\");\n\nvar _bigSign = _interopRequireDefault(require(\"../../util/bigSign\"));\n\nvar _corePlugins = _interopRequireDefault(require(\"../corePlugins\"));\n\nvar sharedState = _interopRequireWildcard(require(\"./sharedState\"));\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction toPath(value) {\n  if (Array.isArray(value)) {\n    return value;\n  }\n\n  let inBrackets = false;\n  let parts = [];\n  let chunk = '';\n\n  for (let i = 0; i < value.length; i++) {\n    let char = value[i];\n\n    if (char === '[') {\n      inBrackets = true;\n      parts.push(chunk);\n      chunk = '';\n      continue;\n    }\n\n    if (char === ']' && inBrackets) {\n      inBrackets = false;\n      parts.push(chunk);\n      chunk = '';\n      continue;\n    }\n\n    if (char === '.' && !inBrackets && chunk.length > 0) {\n      parts.push(chunk);\n      chunk = '';\n      continue;\n    }\n\n    chunk = chunk + char;\n  }\n\n  if (chunk.length > 0) {\n    parts.push(chunk);\n  }\n\n  return parts;\n}\n\nfunction insertInto(list, value, {\n  before = []\n} = {}) {\n  before = [].concat(before);\n\n  if (before.length <= 0) {\n    list.push(value);\n    return;\n  }\n\n  let idx = list.length - 1;\n\n  for (let other of before) {\n    let iidx = list.indexOf(other);\n    if (iidx === -1) continue;\n    idx = Math.min(idx, iidx);\n  }\n\n  list.splice(idx, 0, value);\n}\n\nfunction parseStyles(styles) {\n  if (!Array.isArray(styles)) {\n    return parseStyles([styles]);\n  }\n\n  return styles.flatMap(style => {\n    let isNode = !Array.isArray(style) && !(0, _isPlainObject.default)(style);\n    return isNode ? style : (0, _parseObjectStyles.default)(style);\n  });\n}\n\nfunction getClasses(selector) {\n  let parser = (0, _postcssSelectorParser.default)(selectors => {\n    let allClasses = [];\n    selectors.walkClasses(classNode => {\n      allClasses.push(classNode.value);\n    });\n    return allClasses;\n  });\n  return parser.transformSync(selector);\n}\n\nfunction extractCandidates(node) {\n  let classes = node.type === 'rule' ? getClasses(node.selector) : [];\n\n  if (node.type === 'atrule') {\n    node.walkRules(rule => {\n      classes = [...classes, ...getClasses(rule.selector)];\n    });\n  }\n\n  return classes;\n}\n\nfunction withIdentifiers(styles) {\n  return parseStyles(styles).flatMap(node => {\n    let nodeMap = new Map();\n    let candidates = extractCandidates(node); // If this isn't \"on-demandable\", assign it a universal candidate.\n\n    if (candidates.length === 0) {\n      return [['*', node]];\n    }\n\n    return candidates.map(c => {\n      if (!nodeMap.has(node)) {\n        nodeMap.set(node, node);\n      }\n\n      return [c, nodeMap.get(node)];\n    });\n  });\n}\n\nlet matchingBrackets = new Map([['{', '}'], ['[', ']'], ['(', ')']]);\nlet inverseMatchingBrackets = new Map(Array.from(matchingBrackets.entries()).map(([k, v]) => [v, k]));\nlet quotes = new Set(['\"', \"'\", '`']); // Arbitrary values must contain balanced brackets (), [] and {}. Escaped\n// values don't count, and brackets inside quotes also don't count.\n//\n// E.g.: w-[this-is]w-[weird-and-invalid]\n// E.g.: w-[this-is\\\\]w-\\\\[weird-but-valid]\n// E.g.: content-['this-is-also-valid]-weirdly-enough']\n\nfunction isValidArbitraryValue(value) {\n  let stack = [];\n  let inQuotes = false;\n\n  for (let i = 0; i < value.length; i++) {\n    let char = value[i]; // Non-escaped quotes allow us to \"allow\" anything in between\n\n    if (quotes.has(char) && value[i - 1] !== '\\\\') {\n      inQuotes = !inQuotes;\n    }\n\n    if (inQuotes) continue;\n    if (value[i - 1] === '\\\\') continue; // Escaped\n\n    if (matchingBrackets.has(char)) {\n      stack.push(char);\n    } else if (inverseMatchingBrackets.has(char)) {\n      let inverse = inverseMatchingBrackets.get(char); // Nothing to pop from, therefore it is unbalanced\n\n      if (stack.length <= 0) {\n        return false;\n      } // Popped value must match the inverse value, otherwise it is unbalanced\n\n\n      if (stack.pop() !== inverse) {\n        return false;\n      }\n    }\n  } // If there is still something on the stack, it is also unbalanced\n\n\n  if (stack.length > 0) {\n    return false;\n  } // All good, totally balanced!\n\n\n  return true;\n}\n\nfunction buildPluginApi(tailwindConfig, context, {\n  variantList,\n  variantMap,\n  offsets\n}) {\n  function getConfigValue(path, defaultValue) {\n    return path ? (0, _dlv.default)(tailwindConfig, path, defaultValue) : tailwindConfig;\n  }\n\n  function applyConfiguredPrefix(selector) {\n    return (0, _prefixSelector.default)(tailwindConfig.prefix, selector);\n  }\n\n  function prefixIdentifier(identifier, options) {\n    if (identifier === '*') {\n      return '*';\n    }\n\n    if (!options.respectPrefix) {\n      return identifier;\n    }\n\n    if (typeof context.tailwindConfig.prefix === 'function') {\n      return (0, _prefixSelector.default)(context.tailwindConfig.prefix, `.${identifier}`).substr(1);\n    }\n\n    return context.tailwindConfig.prefix + identifier;\n  }\n\n  return {\n    addVariant(variantName, variantFunctions, options = {}) {\n      variantFunctions = [].concat(variantFunctions);\n      insertInto(variantList, variantName, options);\n      variantMap.set(variantName, variantFunctions);\n    },\n\n    postcss: _postcss.default,\n    prefix: applyConfiguredPrefix,\n    e: _escapeClassName.default,\n    config: getConfigValue,\n\n    theme(path, defaultValue) {\n      const [pathRoot, ...subPaths] = toPath(path);\n      const value = getConfigValue(['theme', pathRoot, ...subPaths], defaultValue);\n      return (0, _transformThemeValue.default)(pathRoot)(value);\n    },\n\n    corePlugins: path => {\n      if (Array.isArray(tailwindConfig.corePlugins)) {\n        return tailwindConfig.corePlugins.includes(path);\n      }\n\n      return getConfigValue(['corePlugins', path], true);\n    },\n    variants: (path, defaultValue) => {\n      if (Array.isArray(tailwindConfig.variants)) {\n        return tailwindConfig.variants;\n      }\n\n      return getConfigValue(['variants', path], defaultValue);\n    },\n\n    addBase(base) {\n      for (let [identifier, rule] of withIdentifiers(base)) {\n        let prefixedIdentifier = prefixIdentifier(identifier, {});\n        let offset = offsets.base++;\n\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n\n        context.candidateRuleMap.get(prefixedIdentifier).push([{\n          sort: offset,\n          layer: 'base'\n        }, rule]);\n      }\n    },\n\n    addComponents(components, options) {\n      let defaultOptions = {\n        variants: [],\n        respectPrefix: true,\n        respectImportant: false,\n        respectVariants: true\n      };\n      options = Object.assign({}, defaultOptions, Array.isArray(options) ? {\n        variants: options\n      } : options);\n\n      for (let [identifier, rule] of withIdentifiers(components)) {\n        let prefixedIdentifier = prefixIdentifier(identifier, options);\n        let offset = offsets.components++;\n\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n\n        context.candidateRuleMap.get(prefixedIdentifier).push([{\n          sort: offset,\n          layer: 'components',\n          options\n        }, rule]);\n      }\n    },\n\n    addUtilities(utilities, options) {\n      let defaultOptions = {\n        variants: [],\n        respectPrefix: true,\n        respectImportant: true,\n        respectVariants: true\n      };\n      options = Object.assign({}, defaultOptions, Array.isArray(options) ? {\n        variants: options\n      } : options);\n\n      for (let [identifier, rule] of withIdentifiers(utilities)) {\n        let prefixedIdentifier = prefixIdentifier(identifier, options);\n        let offset = offsets.utilities++;\n\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n\n        context.candidateRuleMap.get(prefixedIdentifier).push([{\n          sort: offset,\n          layer: 'utilities',\n          options\n        }, rule]);\n      }\n    },\n\n    matchUtilities: function (utilities, options) {\n      let defaultOptions = {\n        variants: [],\n        respectPrefix: true,\n        respectImportant: true,\n        respectVariants: true\n      };\n      options = { ...defaultOptions,\n        ...options\n      };\n      let offset = offsets.utilities++;\n\n      for (let identifier in utilities) {\n        let prefixedIdentifier = prefixIdentifier(identifier, options);\n        let rule = utilities[identifier];\n\n        function wrapped(modifier) {\n          let {\n            type = 'any'\n          } = options;\n          type = [].concat(type);\n          let [value, coercedType] = (0, _pluginUtils.coerceValue)(type, modifier, options.values, tailwindConfig);\n\n          if (!type.includes(coercedType) || value === undefined) {\n            return [];\n          }\n\n          if (!isValidArbitraryValue(value)) {\n            return [];\n          }\n\n          let includedRules = [];\n          let ruleSets = [].concat(rule(value, {\n            includeRules(rules) {\n              includedRules.push(...rules);\n            }\n\n          })).filter(Boolean).map(declaration => ({\n            [(0, _nameClass.default)(identifier, modifier)]: declaration\n          }));\n          return [...includedRules, ...ruleSets];\n        }\n\n        let withOffsets = [{\n          sort: offset,\n          layer: 'utilities',\n          options\n        }, wrapped];\n\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n\n        context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);\n      }\n    }\n  };\n}\n\nlet fileModifiedMapCache = new WeakMap();\n\nfunction getFileModifiedMap(context) {\n  if (!fileModifiedMapCache.has(context)) {\n    fileModifiedMapCache.set(context, new Map());\n  }\n\n  return fileModifiedMapCache.get(context);\n}\n\nfunction trackModified(files, fileModifiedMap) {\n  let changed = false;\n\n  for (let file of files) {\n    if (!file) continue;\n\n    let parsed = _url.default.parse(file);\n\n    let pathname = parsed.hash ? parsed.href.replace(parsed.hash, '') : parsed.href;\n    pathname = parsed.search ? pathname.replace(parsed.search, '') : pathname;\n\n    let newModified = _fs.default.statSync(decodeURIComponent(pathname)).mtimeMs;\n\n    if (!fileModifiedMap.has(file) || newModified > fileModifiedMap.get(file)) {\n      changed = true;\n    }\n\n    fileModifiedMap.set(file, newModified);\n  }\n\n  return changed;\n}\n\nfunction extractVariantAtRules(node) {\n  node.walkAtRules(atRule => {\n    if (['responsive', 'variants'].includes(atRule.name)) {\n      extractVariantAtRules(atRule);\n      atRule.before(atRule.nodes);\n      atRule.remove();\n    }\n  });\n}\n\nfunction collectLayerPlugins(root) {\n  let layerPlugins = [];\n  root.each(node => {\n    if (node.type === 'atrule' && ['responsive', 'variants'].includes(node.name)) {\n      node.name = 'layer';\n      node.params = 'utilities';\n    }\n  }); // Walk @layer rules and treat them like plugins\n\n  root.walkAtRules('layer', layerRule => {\n    extractVariantAtRules(layerRule);\n\n    if (layerRule.params === 'base') {\n      for (let node of layerRule.nodes) {\n        layerPlugins.push(function ({\n          addBase\n        }) {\n          addBase(node, {\n            respectPrefix: false\n          });\n        });\n      }\n\n      layerRule.remove();\n    } else if (layerRule.params === 'components') {\n      for (let node of layerRule.nodes) {\n        layerPlugins.push(function ({\n          addComponents\n        }) {\n          addComponents(node, {\n            respectPrefix: false\n          });\n        });\n      }\n\n      layerRule.remove();\n    } else if (layerRule.params === 'utilities') {\n      for (let node of layerRule.nodes) {\n        layerPlugins.push(function ({\n          addUtilities\n        }) {\n          addUtilities(node, {\n            respectPrefix: false\n          });\n        });\n      }\n\n      layerRule.remove();\n    }\n  });\n  return layerPlugins;\n}\n\nfunction resolvePlugins(context, tailwindDirectives, root) {\n  let corePluginList = Object.entries(_corePlugins.default).map(([name, plugin]) => {\n    if (!context.tailwindConfig.corePlugins.includes(name)) {\n      return null;\n    }\n\n    return plugin;\n  }).filter(Boolean);\n  let userPlugins = context.tailwindConfig.plugins.map(plugin => {\n    if (plugin.__isOptionsFunction) {\n      plugin = plugin();\n    }\n\n    return typeof plugin === 'function' ? plugin : plugin.handler;\n  });\n  let layerPlugins = collectLayerPlugins(root, tailwindDirectives); // TODO: This is a workaround for backwards compatibility, since custom variants\n  // were historically sorted before screen/stackable variants.\n\n  let beforeVariants = [_corePlugins.default['pseudoElementVariants'], _corePlugins.default['pseudoClassVariants']];\n  let afterVariants = [_corePlugins.default['directionVariants'], _corePlugins.default['reducedMotionVariants'], _corePlugins.default['darkVariants'], _corePlugins.default['screenVariants']];\n  return [...corePluginList, ...beforeVariants, ...userPlugins, ...afterVariants, ...layerPlugins];\n}\n\nfunction registerPlugins(plugins, context) {\n  let variantList = [];\n  let variantMap = new Map();\n  let offsets = {\n    base: 0n,\n    components: 0n,\n    utilities: 0n\n  };\n  let pluginApi = buildPluginApi(context.tailwindConfig, context, {\n    variantList,\n    variantMap,\n    offsets\n  });\n\n  for (let plugin of plugins) {\n    if (Array.isArray(plugin)) {\n      for (let pluginItem of plugin) {\n        pluginItem(pluginApi);\n      }\n    } else {\n      plugin(pluginApi);\n    }\n  }\n\n  let highestOffset = (args => args.reduce((m, e) => e > m ? e : m))([offsets.base, offsets.components, offsets.utilities]);\n\n  let reservedBits = BigInt(highestOffset.toString(2).length);\n  context.layerOrder = {\n    base: 1n << reservedBits << 0n,\n    components: 1n << reservedBits << 1n,\n    utilities: 1n << reservedBits << 2n\n  };\n  reservedBits += 3n;\n  let offset = 0;\n  context.variantOrder = new Map(variantList.map((variant, i) => {\n    let variantFunctions = variantMap.get(variant).length;\n    let bits = 1n << BigInt(i + offset) << reservedBits;\n    offset += variantFunctions - 1;\n    return [variant, bits];\n  }).sort(([, a], [, z]) => (0, _bigSign.default)(a - z)));\n  context.minimumScreen = [...context.variantOrder.values()].shift(); // Build variantMap\n\n  for (let [variantName, variantFunctions] of variantMap.entries()) {\n    let sort = context.variantOrder.get(variantName);\n    context.variantMap.set(variantName, variantFunctions.map((variantFunction, idx) => [sort << BigInt(idx), variantFunction]));\n  }\n}\n\nfunction createContext(tailwindConfig, changedContent = [], tailwindDirectives = new Set(), root = _postcss.default.root()) {\n  let context = {\n    disposables: [],\n    ruleCache: new Set(),\n    classCache: new Map(),\n    applyClassCache: new Map(),\n    notClassCache: new Set(),\n    postCssNodeCache: new Map(),\n    candidateRuleMap: new Map(),\n    tailwindConfig,\n    changedContent: changedContent,\n    variantMap: new Map(),\n    stylesheetCache: null\n  };\n  let resolvedPlugins = resolvePlugins(context, tailwindDirectives, root);\n  registerPlugins(resolvedPlugins, context);\n  return context;\n}\n\nlet contextMap = sharedState.contextMap;\nlet configContextMap = sharedState.configContextMap;\nlet contextSourcesMap = sharedState.contextSourcesMap;\n\nfunction getContext(tailwindDirectives, root, result, tailwindConfig, userConfigPath, tailwindConfigHash, contextDependencies) {\n  let sourcePath = result.opts.from;\n  let isConfigFile = userConfigPath !== null;\n  sharedState.env.DEBUG && console.log('Source path:', sourcePath);\n  let existingContext;\n\n  if (isConfigFile && contextMap.has(sourcePath)) {\n    existingContext = contextMap.get(sourcePath);\n  } else if (configContextMap.has(tailwindConfigHash)) {\n    let context = configContextMap.get(tailwindConfigHash);\n    contextSourcesMap.get(context).add(sourcePath);\n    contextMap.set(sourcePath, context);\n    existingContext = context;\n  } // If there's already a context in the cache and we don't need to\n  // reset the context, return the cached context.\n\n\n  if (existingContext) {\n    let contextDependenciesChanged = trackModified([...contextDependencies], getFileModifiedMap(existingContext));\n\n    if (!contextDependenciesChanged) {\n      return [existingContext, false];\n    }\n  } // If this source is in the context map, get the old context.\n  // Remove this source from the context sources for the old context,\n  // and clean up that context if no one else is using it. This can be\n  // called by many processes in rapid succession, so we check for presence\n  // first because the first process to run this code will wipe it out first.\n\n\n  if (contextMap.has(sourcePath)) {\n    let oldContext = contextMap.get(sourcePath);\n\n    if (contextSourcesMap.has(oldContext)) {\n      contextSourcesMap.get(oldContext).delete(sourcePath);\n\n      if (contextSourcesMap.get(oldContext).size === 0) {\n        contextSourcesMap.delete(oldContext);\n\n        for (let [tailwindConfigHash, context] of configContextMap) {\n          if (context === oldContext) {\n            configContextMap.delete(tailwindConfigHash);\n          }\n        }\n\n        for (let disposable of oldContext.disposables.splice(0)) {\n          disposable(oldContext);\n        }\n      }\n    }\n  }\n\n  sharedState.env.DEBUG && console.log('Setting up new context...');\n  let context = createContext(tailwindConfig, [], tailwindDirectives, root);\n  trackModified([...contextDependencies], getFileModifiedMap(context)); // ---\n  // Update all context tracking state\n\n  configContextMap.set(tailwindConfigHash, context);\n  contextMap.set(sourcePath, context);\n\n  if (!contextSourcesMap.has(context)) {\n    contextSourcesMap.set(context, new Set());\n  }\n\n  contextSourcesMap.get(context).add(sourcePath);\n  return [context, true];\n}"]},"metadata":{},"sourceType":"script"}