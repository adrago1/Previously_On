{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = parseAnimationValue;\nconst DIRECTIONS = new Set(['normal', 'reverse', 'alternate', 'alternate-reverse']);\nconst PLAY_STATES = new Set(['running', 'paused']);\nconst FILL_MODES = new Set(['none', 'forwards', 'backwards', 'both']);\nconst ITERATION_COUNTS = new Set(['infinite']);\nconst TIMINGS = new Set(['linear', 'ease', 'ease-in', 'ease-out', 'ease-in-out', 'step-start', 'step-end']);\nconst TIMING_FNS = ['cubic-bezier', 'steps'];\nconst COMMA = /\\,(?![^(]*\\))/g; // Comma separator that is not located between brackets. E.g.: `cubiz-bezier(a, b, c)` these don't count.\n\nconst SPACE = /\\ +(?![^(]*\\))/g; // Similar to the one above, but with spaces instead.\n\nconst TIME = /^(-?[\\d.]+m?s)$/;\nconst DIGIT = /^(\\d+)$/;\n\nfunction parseAnimationValue(input) {\n  let animations = input.split(COMMA);\n  return animations.map(animation => {\n    let value = animation.trim();\n    let result = {\n      value\n    };\n    let parts = value.split(SPACE);\n    let seen = new Set();\n\n    for (let part of parts) {\n      if (!seen.has('DIRECTIONS') && DIRECTIONS.has(part)) {\n        result.direction = part;\n        seen.add('DIRECTIONS');\n      } else if (!seen.has('PLAY_STATES') && PLAY_STATES.has(part)) {\n        result.playState = part;\n        seen.add('PLAY_STATES');\n      } else if (!seen.has('FILL_MODES') && FILL_MODES.has(part)) {\n        result.fillMode = part;\n        seen.add('FILL_MODES');\n      } else if (!seen.has('ITERATION_COUNTS') && (ITERATION_COUNTS.has(part) || DIGIT.test(part))) {\n        result.iterationCount = part;\n        seen.add('ITERATION_COUNTS');\n      } else if (!seen.has('TIMING_FUNCTION') && TIMINGS.has(part)) {\n        result.timingFunction = part;\n        seen.add('TIMING_FUNCTION');\n      } else if (!seen.has('TIMING_FUNCTION') && TIMING_FNS.some(f => part.startsWith(`${f}(`))) {\n        result.timingFunction = part;\n        seen.add('TIMING_FUNCTION');\n      } else if (!seen.has('DURATION') && TIME.test(part)) {\n        result.duration = part;\n        seen.add('DURATION');\n      } else if (!seen.has('DELAY') && TIME.test(part)) {\n        result.delay = part;\n        seen.add('DELAY');\n      } else result.name = part;\n    }\n\n    return result;\n  });\n}","map":{"version":3,"sources":["/home/alan/delivery_2/previously_on/client/node_modules/tailwindcss/lib/util/parseAnimationValue.js"],"names":["Object","defineProperty","exports","value","default","parseAnimationValue","DIRECTIONS","Set","PLAY_STATES","FILL_MODES","ITERATION_COUNTS","TIMINGS","TIMING_FNS","COMMA","SPACE","TIME","DIGIT","input","animations","split","map","animation","trim","result","parts","seen","part","has","direction","add","playState","fillMode","test","iterationCount","timingFunction","some","f","startsWith","duration","delay","name"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = parseAnimationValue;\nconst DIRECTIONS = new Set(['normal', 'reverse', 'alternate', 'alternate-reverse']);\nconst PLAY_STATES = new Set(['running', 'paused']);\nconst FILL_MODES = new Set(['none', 'forwards', 'backwards', 'both']);\nconst ITERATION_COUNTS = new Set(['infinite']);\nconst TIMINGS = new Set(['linear', 'ease', 'ease-in', 'ease-out', 'ease-in-out', 'step-start', 'step-end']);\nconst TIMING_FNS = ['cubic-bezier', 'steps'];\nconst COMMA = /\\,(?![^(]*\\))/g; // Comma separator that is not located between brackets. E.g.: `cubiz-bezier(a, b, c)` these don't count.\n\nconst SPACE = /\\ +(?![^(]*\\))/g; // Similar to the one above, but with spaces instead.\n\nconst TIME = /^(-?[\\d.]+m?s)$/;\nconst DIGIT = /^(\\d+)$/;\n\nfunction parseAnimationValue(input) {\n  let animations = input.split(COMMA);\n  return animations.map(animation => {\n    let value = animation.trim();\n    let result = {\n      value\n    };\n    let parts = value.split(SPACE);\n    let seen = new Set();\n\n    for (let part of parts) {\n      if (!seen.has('DIRECTIONS') && DIRECTIONS.has(part)) {\n        result.direction = part;\n        seen.add('DIRECTIONS');\n      } else if (!seen.has('PLAY_STATES') && PLAY_STATES.has(part)) {\n        result.playState = part;\n        seen.add('PLAY_STATES');\n      } else if (!seen.has('FILL_MODES') && FILL_MODES.has(part)) {\n        result.fillMode = part;\n        seen.add('FILL_MODES');\n      } else if (!seen.has('ITERATION_COUNTS') && (ITERATION_COUNTS.has(part) || DIGIT.test(part))) {\n        result.iterationCount = part;\n        seen.add('ITERATION_COUNTS');\n      } else if (!seen.has('TIMING_FUNCTION') && TIMINGS.has(part)) {\n        result.timingFunction = part;\n        seen.add('TIMING_FUNCTION');\n      } else if (!seen.has('TIMING_FUNCTION') && TIMING_FNS.some(f => part.startsWith(`${f}(`))) {\n        result.timingFunction = part;\n        seen.add('TIMING_FUNCTION');\n      } else if (!seen.has('DURATION') && TIME.test(part)) {\n        result.duration = part;\n        seen.add('DURATION');\n      } else if (!seen.has('DELAY') && TIME.test(part)) {\n        result.delay = part;\n        seen.add('DELAY');\n      } else result.name = part;\n    }\n\n    return result;\n  });\n}"]},"metadata":{},"sourceType":"script"}