{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = setupWatchingContext;\n\nvar _fs = _interopRequireDefault(require(\"fs\"));\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _tmp = _interopRequireDefault(require(\"tmp\"));\n\nvar _chokidar = _interopRequireDefault(require(\"chokidar\"));\n\nvar _fastGlob = _interopRequireDefault(require(\"fast-glob\"));\n\nvar _quickLru = _interopRequireDefault(require(\"quick-lru\"));\n\nvar _normalizePath = _interopRequireDefault(require(\"normalize-path\"));\n\nvar _hashConfig = _interopRequireDefault(require(\"../../util/hashConfig\"));\n\nvar _log = _interopRequireDefault(require(\"../../util/log\"));\n\nvar _getModuleDependencies = _interopRequireDefault(require(\"../../lib/getModuleDependencies\"));\n\nvar _resolveConfig = _interopRequireDefault(require(\"../../../resolveConfig\"));\n\nvar _resolveConfigPath = _interopRequireDefault(require(\"../../util/resolveConfigPath\"));\n\nvar _setupContextUtils = require(\"./setupContextUtils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // This is used to trigger rebuilds. Just updating the timestamp\n// is significantly faster than actually writing to the file (10x).\n\n\nfunction touch(filename) {\n  let time = new Date();\n\n  try {\n    _fs.default.utimesSync(filename, time, time);\n  } catch (err) {\n    _fs.default.closeSync(_fs.default.openSync(filename, 'w'));\n  }\n}\n\nlet watchers = new WeakMap();\n\nfunction getWatcher(context) {\n  if (watchers.has(context)) {\n    return watchers.get(context);\n  }\n\n  return null;\n}\n\nfunction setWatcher(context, watcher) {\n  return watchers.set(context, watcher);\n}\n\nlet touchFiles = new WeakMap();\n\nfunction getTouchFile(context) {\n  if (touchFiles.has(context)) {\n    return touchFiles.get(context);\n  }\n\n  return null;\n}\n\nfunction setTouchFile(context, touchFile) {\n  return touchFiles.set(context, touchFile);\n}\n\nlet configPaths = new WeakMap();\n\nfunction getConfigPath(context, configOrPath) {\n  if (!configPaths.has(context)) {\n    configPaths.set(context, (0, _resolveConfigPath.default)(configOrPath));\n  }\n\n  return configPaths.get(context);\n}\n\nfunction rebootWatcher(context, configPath, configDependencies, candidateFiles) {\n  let touchFile = getTouchFile(context);\n\n  if (touchFile === null) {\n    touchFile = _tmp.default.fileSync().name;\n    setTouchFile(context, touchFile);\n    touch(touchFile);\n  }\n\n  let watcher = getWatcher(context);\n  Promise.resolve(watcher ? watcher.close() : null).then(() => {\n    _log.default.info(['Tailwind CSS is watching for changes...', 'https://tailwindcss.com/docs/just-in-time-mode#watch-mode-and-one-off-builds']);\n\n    watcher = _chokidar.default.watch([...candidateFiles, ...configDependencies], {\n      ignoreInitial: true\n    });\n    setWatcher(context, watcher);\n    watcher.on('add', file => {\n      let changedFile = _path.default.resolve('.', file);\n\n      let content = _fs.default.readFileSync(changedFile, 'utf8');\n\n      let extension = _path.default.extname(changedFile).slice(1);\n\n      context.changedContent.push({\n        content,\n        extension\n      });\n      touch(touchFile);\n    });\n    watcher.on('change', file => {\n      // If it was a config dependency, touch the config file to trigger a new context.\n      // This is not really that clean of a solution but it's the fastest, because we\n      // can do a very quick check on each build to see if the config has changed instead\n      // of having to get all of the module dependencies and check every timestamp each\n      // time.\n      if (configDependencies.has(file)) {\n        for (let dependency of configDependencies) {\n          delete require.cache[require.resolve(dependency)];\n        }\n\n        touch(configPath);\n      } else {\n        let changedFile = _path.default.resolve('.', file);\n\n        let content = _fs.default.readFileSync(changedFile, 'utf8');\n\n        let extension = _path.default.extname(changedFile).slice(1);\n\n        context.changedContent.push({\n          content,\n          extension\n        });\n        touch(touchFile);\n      }\n    });\n    watcher.on('unlink', file => {\n      // Touch the config file if any of the dependencies are deleted.\n      if (configDependencies.has(file)) {\n        for (let dependency of configDependencies) {\n          delete require.cache[require.resolve(dependency)];\n        }\n\n        touch(configPath);\n      }\n    });\n  });\n}\n\nlet configPathCache = new _quickLru.default({\n  maxSize: 100\n});\nlet configDependenciesCache = new WeakMap();\n\nfunction getConfigDependencies(context) {\n  if (!configDependenciesCache.has(context)) {\n    configDependenciesCache.set(context, new Set());\n  }\n\n  return configDependenciesCache.get(context);\n}\n\nlet candidateFilesCache = new WeakMap();\n\nfunction getCandidateFiles(context, tailwindConfig) {\n  if (candidateFilesCache.has(context)) {\n    return candidateFilesCache.get(context);\n  }\n\n  let purgeContent = Array.isArray(tailwindConfig.purge) ? tailwindConfig.purge : tailwindConfig.purge.content;\n  let candidateFiles = purgeContent.filter(item => typeof item === 'string').map(purgePath => (0, _normalizePath.default)(_path.default.resolve(purgePath)));\n  return candidateFilesCache.set(context, candidateFiles).get(context);\n} // Get the config object based on a path\n\n\nfunction getTailwindConfig(configOrPath) {\n  let userConfigPath = (0, _resolveConfigPath.default)(configOrPath);\n\n  if (userConfigPath !== null) {\n    let [prevConfig, prevModified = -Infinity, prevConfigHash] = configPathCache.get(userConfigPath) || [];\n\n    let modified = _fs.default.statSync(userConfigPath).mtimeMs; // It hasn't changed (based on timestamp)\n\n\n    if (modified <= prevModified) {\n      return [prevConfig, userConfigPath, prevConfigHash, [userConfigPath]];\n    } // It has changed (based on timestamp), or first run\n\n\n    delete require.cache[userConfigPath];\n    let newConfig = (0, _resolveConfig.default)(require(userConfigPath));\n    let newHash = (0, _hashConfig.default)(newConfig);\n    configPathCache.set(userConfigPath, [newConfig, modified, newHash]);\n    return [newConfig, userConfigPath, newHash, [userConfigPath]];\n  } // It's a plain object, not a path\n\n\n  let newConfig = (0, _resolveConfig.default)(configOrPath.config === undefined ? configOrPath : configOrPath.config);\n  return [newConfig, null, (0, _hashConfig.default)(newConfig), []];\n}\n\nfunction resolvedChangedContent(context, candidateFiles) {\n  var _context$tailwindConf, _context$tailwindConf2;\n\n  let changedContent = (Array.isArray(context.tailwindConfig.purge) ? context.tailwindConfig.purge : context.tailwindConfig.purge.content).filter(item => typeof item.raw === 'string').concat(((_context$tailwindConf = (_context$tailwindConf2 = context.tailwindConfig.purge) === null || _context$tailwindConf2 === void 0 ? void 0 : _context$tailwindConf2.safelist) !== null && _context$tailwindConf !== void 0 ? _context$tailwindConf : []).map(content => {\n    if (typeof content === 'string') {\n      return {\n        raw: content,\n        extension: 'html'\n      };\n    }\n\n    if (content instanceof RegExp) {\n      throw new Error(\"Values inside 'purge.safelist' can only be of type 'string', found 'regex'.\");\n    }\n\n    throw new Error(`Values inside 'purge.safelist' can only be of type 'string', found '${typeof content}'.`);\n  })).map(({\n    raw,\n    extension\n  }) => ({\n    content: raw,\n    extension\n  }));\n\n  for (let changedFile of resolveChangedFiles(context, candidateFiles)) {\n    let content = _fs.default.readFileSync(changedFile, 'utf8');\n\n    let extension = _path.default.extname(changedFile).slice(1);\n\n    changedContent.push({\n      content,\n      extension\n    });\n  }\n\n  return changedContent;\n}\n\nlet scannedContentCache = new WeakMap();\n\nfunction resolveChangedFiles(context, candidateFiles) {\n  let changedFiles = new Set(); // If we're not set up and watching files ourselves, we need to do\n  // the work of grabbing all of the template files for candidate\n  // detection.\n\n  if (!scannedContentCache.has(context)) {\n    let files = _fastGlob.default.sync(candidateFiles);\n\n    for (let file of files) {\n      changedFiles.add(file);\n    }\n\n    scannedContentCache.set(context, true);\n  }\n\n  return changedFiles;\n} // DISABLE_TOUCH = FALSE\n// Retrieve an existing context from cache if possible (since contexts are unique per\n// source path), or set up a new one (including setting up watchers and registering\n// plugins) then return it\n\n\nfunction setupWatchingContext(configOrPath) {\n  return ({\n    tailwindDirectives,\n    registerDependency\n  }) => {\n    return (root, result) => {\n      let [tailwindConfig, userConfigPath, tailwindConfigHash, configDependencies] = getTailwindConfig(configOrPath);\n      let contextDependencies = new Set(configDependencies); // If there are no @tailwind rules, we don't consider this CSS file or it's dependencies\n      // to be dependencies of the context. Can reuse the context even if they change.\n      // We may want to think about `@layer` being part of this trigger too, but it's tough\n      // because it's impossible for a layer in one file to end up in the actual @tailwind rule\n      // in another file since independent sources are effectively isolated.\n\n      if (tailwindDirectives.size > 0) {\n        // Add current css file as a context dependencies.\n        contextDependencies.add(result.opts.from); // Add all css @import dependencies as context dependencies.\n\n        for (let message of result.messages) {\n          if (message.type === 'dependency') {\n            contextDependencies.add(message.file);\n          }\n        }\n      }\n\n      let [context, isNewContext] = (0, _setupContextUtils.getContext)(tailwindDirectives, root, result, tailwindConfig, userConfigPath, tailwindConfigHash, contextDependencies);\n      let candidateFiles = getCandidateFiles(context, tailwindConfig);\n      let contextConfigDependencies = getConfigDependencies(context);\n\n      for (let file of configDependencies) {\n        registerDependency({\n          type: 'dependency',\n          file\n        });\n      }\n\n      context.disposables.push(oldContext => {\n        let watcher = getWatcher(oldContext);\n\n        if (watcher !== null) {\n          watcher.close();\n        }\n      });\n      let configPath = getConfigPath(context, configOrPath);\n\n      if (configPath !== null) {\n        for (let dependency of (0, _getModuleDependencies.default)(configPath)) {\n          if (dependency.file === configPath) {\n            continue;\n          }\n\n          contextConfigDependencies.add(dependency.file);\n        }\n      }\n\n      if (isNewContext) {\n        rebootWatcher(context, configPath, contextConfigDependencies, candidateFiles);\n      } // Register our temp file as a dependency ‚Äî we write to this file\n      // to trigger rebuilds.\n\n\n      let touchFile = getTouchFile(context);\n\n      if (touchFile) {\n        registerDependency({\n          type: 'dependency',\n          file: touchFile\n        });\n      }\n\n      if (tailwindDirectives.size > 0) {\n        for (let changedContent of resolvedChangedContent(context, candidateFiles)) {\n          context.changedContent.push(changedContent);\n        }\n      }\n\n      return context;\n    };\n  };\n}","map":{"version":3,"sources":["/home/alan/delivery_2/previously_on/client/node_modules/tailwindcss/lib/jit/lib/setupWatchingContext.js"],"names":["Object","defineProperty","exports","value","default","setupWatchingContext","_fs","_interopRequireDefault","require","_path","_tmp","_chokidar","_fastGlob","_quickLru","_normalizePath","_hashConfig","_log","_getModuleDependencies","_resolveConfig","_resolveConfigPath","_setupContextUtils","obj","__esModule","touch","filename","time","Date","utimesSync","err","closeSync","openSync","watchers","WeakMap","getWatcher","context","has","get","setWatcher","watcher","set","touchFiles","getTouchFile","setTouchFile","touchFile","configPaths","getConfigPath","configOrPath","rebootWatcher","configPath","configDependencies","candidateFiles","fileSync","name","Promise","resolve","close","then","info","watch","ignoreInitial","on","file","changedFile","content","readFileSync","extension","extname","slice","changedContent","push","dependency","cache","configPathCache","maxSize","configDependenciesCache","getConfigDependencies","Set","candidateFilesCache","getCandidateFiles","tailwindConfig","purgeContent","Array","isArray","purge","filter","item","map","purgePath","getTailwindConfig","userConfigPath","prevConfig","prevModified","Infinity","prevConfigHash","modified","statSync","mtimeMs","newConfig","newHash","config","undefined","resolvedChangedContent","_context$tailwindConf","_context$tailwindConf2","raw","concat","safelist","RegExp","Error","resolveChangedFiles","scannedContentCache","changedFiles","files","sync","add","tailwindDirectives","registerDependency","root","result","tailwindConfigHash","contextDependencies","size","opts","from","message","messages","type","isNewContext","getContext","contextConfigDependencies","disposables","oldContext"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = setupWatchingContext;\n\nvar _fs = _interopRequireDefault(require(\"fs\"));\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _tmp = _interopRequireDefault(require(\"tmp\"));\n\nvar _chokidar = _interopRequireDefault(require(\"chokidar\"));\n\nvar _fastGlob = _interopRequireDefault(require(\"fast-glob\"));\n\nvar _quickLru = _interopRequireDefault(require(\"quick-lru\"));\n\nvar _normalizePath = _interopRequireDefault(require(\"normalize-path\"));\n\nvar _hashConfig = _interopRequireDefault(require(\"../../util/hashConfig\"));\n\nvar _log = _interopRequireDefault(require(\"../../util/log\"));\n\nvar _getModuleDependencies = _interopRequireDefault(require(\"../../lib/getModuleDependencies\"));\n\nvar _resolveConfig = _interopRequireDefault(require(\"../../../resolveConfig\"));\n\nvar _resolveConfigPath = _interopRequireDefault(require(\"../../util/resolveConfigPath\"));\n\nvar _setupContextUtils = require(\"./setupContextUtils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// This is used to trigger rebuilds. Just updating the timestamp\n// is significantly faster than actually writing to the file (10x).\nfunction touch(filename) {\n  let time = new Date();\n\n  try {\n    _fs.default.utimesSync(filename, time, time);\n  } catch (err) {\n    _fs.default.closeSync(_fs.default.openSync(filename, 'w'));\n  }\n}\n\nlet watchers = new WeakMap();\n\nfunction getWatcher(context) {\n  if (watchers.has(context)) {\n    return watchers.get(context);\n  }\n\n  return null;\n}\n\nfunction setWatcher(context, watcher) {\n  return watchers.set(context, watcher);\n}\n\nlet touchFiles = new WeakMap();\n\nfunction getTouchFile(context) {\n  if (touchFiles.has(context)) {\n    return touchFiles.get(context);\n  }\n\n  return null;\n}\n\nfunction setTouchFile(context, touchFile) {\n  return touchFiles.set(context, touchFile);\n}\n\nlet configPaths = new WeakMap();\n\nfunction getConfigPath(context, configOrPath) {\n  if (!configPaths.has(context)) {\n    configPaths.set(context, (0, _resolveConfigPath.default)(configOrPath));\n  }\n\n  return configPaths.get(context);\n}\n\nfunction rebootWatcher(context, configPath, configDependencies, candidateFiles) {\n  let touchFile = getTouchFile(context);\n\n  if (touchFile === null) {\n    touchFile = _tmp.default.fileSync().name;\n    setTouchFile(context, touchFile);\n    touch(touchFile);\n  }\n\n  let watcher = getWatcher(context);\n  Promise.resolve(watcher ? watcher.close() : null).then(() => {\n    _log.default.info(['Tailwind CSS is watching for changes...', 'https://tailwindcss.com/docs/just-in-time-mode#watch-mode-and-one-off-builds']);\n\n    watcher = _chokidar.default.watch([...candidateFiles, ...configDependencies], {\n      ignoreInitial: true\n    });\n    setWatcher(context, watcher);\n    watcher.on('add', file => {\n      let changedFile = _path.default.resolve('.', file);\n\n      let content = _fs.default.readFileSync(changedFile, 'utf8');\n\n      let extension = _path.default.extname(changedFile).slice(1);\n\n      context.changedContent.push({\n        content,\n        extension\n      });\n      touch(touchFile);\n    });\n    watcher.on('change', file => {\n      // If it was a config dependency, touch the config file to trigger a new context.\n      // This is not really that clean of a solution but it's the fastest, because we\n      // can do a very quick check on each build to see if the config has changed instead\n      // of having to get all of the module dependencies and check every timestamp each\n      // time.\n      if (configDependencies.has(file)) {\n        for (let dependency of configDependencies) {\n          delete require.cache[require.resolve(dependency)];\n        }\n\n        touch(configPath);\n      } else {\n        let changedFile = _path.default.resolve('.', file);\n\n        let content = _fs.default.readFileSync(changedFile, 'utf8');\n\n        let extension = _path.default.extname(changedFile).slice(1);\n\n        context.changedContent.push({\n          content,\n          extension\n        });\n        touch(touchFile);\n      }\n    });\n    watcher.on('unlink', file => {\n      // Touch the config file if any of the dependencies are deleted.\n      if (configDependencies.has(file)) {\n        for (let dependency of configDependencies) {\n          delete require.cache[require.resolve(dependency)];\n        }\n\n        touch(configPath);\n      }\n    });\n  });\n}\n\nlet configPathCache = new _quickLru.default({\n  maxSize: 100\n});\nlet configDependenciesCache = new WeakMap();\n\nfunction getConfigDependencies(context) {\n  if (!configDependenciesCache.has(context)) {\n    configDependenciesCache.set(context, new Set());\n  }\n\n  return configDependenciesCache.get(context);\n}\n\nlet candidateFilesCache = new WeakMap();\n\nfunction getCandidateFiles(context, tailwindConfig) {\n  if (candidateFilesCache.has(context)) {\n    return candidateFilesCache.get(context);\n  }\n\n  let purgeContent = Array.isArray(tailwindConfig.purge) ? tailwindConfig.purge : tailwindConfig.purge.content;\n  let candidateFiles = purgeContent.filter(item => typeof item === 'string').map(purgePath => (0, _normalizePath.default)(_path.default.resolve(purgePath)));\n  return candidateFilesCache.set(context, candidateFiles).get(context);\n} // Get the config object based on a path\n\n\nfunction getTailwindConfig(configOrPath) {\n  let userConfigPath = (0, _resolveConfigPath.default)(configOrPath);\n\n  if (userConfigPath !== null) {\n    let [prevConfig, prevModified = -Infinity, prevConfigHash] = configPathCache.get(userConfigPath) || [];\n\n    let modified = _fs.default.statSync(userConfigPath).mtimeMs; // It hasn't changed (based on timestamp)\n\n\n    if (modified <= prevModified) {\n      return [prevConfig, userConfigPath, prevConfigHash, [userConfigPath]];\n    } // It has changed (based on timestamp), or first run\n\n\n    delete require.cache[userConfigPath];\n    let newConfig = (0, _resolveConfig.default)(require(userConfigPath));\n    let newHash = (0, _hashConfig.default)(newConfig);\n    configPathCache.set(userConfigPath, [newConfig, modified, newHash]);\n    return [newConfig, userConfigPath, newHash, [userConfigPath]];\n  } // It's a plain object, not a path\n\n\n  let newConfig = (0, _resolveConfig.default)(configOrPath.config === undefined ? configOrPath : configOrPath.config);\n  return [newConfig, null, (0, _hashConfig.default)(newConfig), []];\n}\n\nfunction resolvedChangedContent(context, candidateFiles) {\n  var _context$tailwindConf, _context$tailwindConf2;\n\n  let changedContent = (Array.isArray(context.tailwindConfig.purge) ? context.tailwindConfig.purge : context.tailwindConfig.purge.content).filter(item => typeof item.raw === 'string').concat(((_context$tailwindConf = (_context$tailwindConf2 = context.tailwindConfig.purge) === null || _context$tailwindConf2 === void 0 ? void 0 : _context$tailwindConf2.safelist) !== null && _context$tailwindConf !== void 0 ? _context$tailwindConf : []).map(content => {\n    if (typeof content === 'string') {\n      return {\n        raw: content,\n        extension: 'html'\n      };\n    }\n\n    if (content instanceof RegExp) {\n      throw new Error(\"Values inside 'purge.safelist' can only be of type 'string', found 'regex'.\");\n    }\n\n    throw new Error(`Values inside 'purge.safelist' can only be of type 'string', found '${typeof content}'.`);\n  })).map(({\n    raw,\n    extension\n  }) => ({\n    content: raw,\n    extension\n  }));\n\n  for (let changedFile of resolveChangedFiles(context, candidateFiles)) {\n    let content = _fs.default.readFileSync(changedFile, 'utf8');\n\n    let extension = _path.default.extname(changedFile).slice(1);\n\n    changedContent.push({\n      content,\n      extension\n    });\n  }\n\n  return changedContent;\n}\n\nlet scannedContentCache = new WeakMap();\n\nfunction resolveChangedFiles(context, candidateFiles) {\n  let changedFiles = new Set(); // If we're not set up and watching files ourselves, we need to do\n  // the work of grabbing all of the template files for candidate\n  // detection.\n\n  if (!scannedContentCache.has(context)) {\n    let files = _fastGlob.default.sync(candidateFiles);\n\n    for (let file of files) {\n      changedFiles.add(file);\n    }\n\n    scannedContentCache.set(context, true);\n  }\n\n  return changedFiles;\n} // DISABLE_TOUCH = FALSE\n// Retrieve an existing context from cache if possible (since contexts are unique per\n// source path), or set up a new one (including setting up watchers and registering\n// plugins) then return it\n\n\nfunction setupWatchingContext(configOrPath) {\n  return ({\n    tailwindDirectives,\n    registerDependency\n  }) => {\n    return (root, result) => {\n      let [tailwindConfig, userConfigPath, tailwindConfigHash, configDependencies] = getTailwindConfig(configOrPath);\n      let contextDependencies = new Set(configDependencies); // If there are no @tailwind rules, we don't consider this CSS file or it's dependencies\n      // to be dependencies of the context. Can reuse the context even if they change.\n      // We may want to think about `@layer` being part of this trigger too, but it's tough\n      // because it's impossible for a layer in one file to end up in the actual @tailwind rule\n      // in another file since independent sources are effectively isolated.\n\n      if (tailwindDirectives.size > 0) {\n        // Add current css file as a context dependencies.\n        contextDependencies.add(result.opts.from); // Add all css @import dependencies as context dependencies.\n\n        for (let message of result.messages) {\n          if (message.type === 'dependency') {\n            contextDependencies.add(message.file);\n          }\n        }\n      }\n\n      let [context, isNewContext] = (0, _setupContextUtils.getContext)(tailwindDirectives, root, result, tailwindConfig, userConfigPath, tailwindConfigHash, contextDependencies);\n      let candidateFiles = getCandidateFiles(context, tailwindConfig);\n      let contextConfigDependencies = getConfigDependencies(context);\n\n      for (let file of configDependencies) {\n        registerDependency({\n          type: 'dependency',\n          file\n        });\n      }\n\n      context.disposables.push(oldContext => {\n        let watcher = getWatcher(oldContext);\n\n        if (watcher !== null) {\n          watcher.close();\n        }\n      });\n      let configPath = getConfigPath(context, configOrPath);\n\n      if (configPath !== null) {\n        for (let dependency of (0, _getModuleDependencies.default)(configPath)) {\n          if (dependency.file === configPath) {\n            continue;\n          }\n\n          contextConfigDependencies.add(dependency.file);\n        }\n      }\n\n      if (isNewContext) {\n        rebootWatcher(context, configPath, contextConfigDependencies, candidateFiles);\n      } // Register our temp file as a dependency ‚Äî we write to this file\n      // to trigger rebuilds.\n\n\n      let touchFile = getTouchFile(context);\n\n      if (touchFile) {\n        registerDependency({\n          type: 'dependency',\n          file: touchFile\n        });\n      }\n\n      if (tailwindDirectives.size > 0) {\n        for (let changedContent of resolvedChangedContent(context, candidateFiles)) {\n          context.changedContent.push(changedContent);\n        }\n      }\n\n      return context;\n    };\n  };\n}"]},"metadata":{},"sourceType":"script"}