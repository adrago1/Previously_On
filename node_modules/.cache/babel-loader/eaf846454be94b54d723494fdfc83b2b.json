{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils = require(\"../../utils\");\n\nclass Matcher {\n  constructor(_patterns, _settings, _micromatchOptions) {\n    this._patterns = _patterns;\n    this._settings = _settings;\n    this._micromatchOptions = _micromatchOptions;\n    this._storage = [];\n\n    this._fillStorage();\n  }\n\n  _fillStorage() {\n    /**\n     * The original pattern may include `{,*,**,a/*}`, which will lead to problems with matching (unresolved level).\n     * So, before expand patterns with brace expansion into separated patterns.\n     */\n    const patterns = utils.pattern.expandPatternsWithBraceExpansion(this._patterns);\n\n    for (const pattern of patterns) {\n      const segments = this._getPatternSegments(pattern);\n\n      const sections = this._splitSegmentsIntoSections(segments);\n\n      this._storage.push({\n        complete: sections.length <= 1,\n        pattern,\n        segments,\n        sections\n      });\n    }\n  }\n\n  _getPatternSegments(pattern) {\n    const parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);\n    return parts.map(part => {\n      const dynamic = utils.pattern.isDynamicPattern(part, this._settings);\n\n      if (!dynamic) {\n        return {\n          dynamic: false,\n          pattern: part\n        };\n      }\n\n      return {\n        dynamic: true,\n        pattern: part,\n        patternRe: utils.pattern.makeRe(part, this._micromatchOptions)\n      };\n    });\n  }\n\n  _splitSegmentsIntoSections(segments) {\n    return utils.array.splitWhen(segments, segment => segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));\n  }\n\n}\n\nexports.default = Matcher;","map":{"version":3,"sources":["/home/alan/delivery_2/previously_on/client/node_modules/fast-glob/out/providers/matchers/matcher.js"],"names":["Object","defineProperty","exports","value","utils","require","Matcher","constructor","_patterns","_settings","_micromatchOptions","_storage","_fillStorage","patterns","pattern","expandPatternsWithBraceExpansion","segments","_getPatternSegments","sections","_splitSegmentsIntoSections","push","complete","length","parts","getPatternParts","map","part","dynamic","isDynamicPattern","patternRe","makeRe","array","splitWhen","segment","hasGlobStar","default"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,MAAMC,KAAK,GAAGC,OAAO,CAAC,aAAD,CAArB;;AACA,MAAMC,OAAN,CAAc;AACVC,EAAAA,WAAW,CAACC,SAAD,EAAYC,SAAZ,EAAuBC,kBAAvB,EAA2C;AAClD,SAAKF,SAAL,GAAiBA,SAAjB;AACA,SAAKC,SAAL,GAAiBA,SAAjB;AACA,SAAKC,kBAAL,GAA0BA,kBAA1B;AACA,SAAKC,QAAL,GAAgB,EAAhB;;AACA,SAAKC,YAAL;AACH;;AACDA,EAAAA,YAAY,GAAG;AACX;AACR;AACA;AACA;AACQ,UAAMC,QAAQ,GAAGT,KAAK,CAACU,OAAN,CAAcC,gCAAd,CAA+C,KAAKP,SAApD,CAAjB;;AACA,SAAK,MAAMM,OAAX,IAAsBD,QAAtB,EAAgC;AAC5B,YAAMG,QAAQ,GAAG,KAAKC,mBAAL,CAAyBH,OAAzB,CAAjB;;AACA,YAAMI,QAAQ,GAAG,KAAKC,0BAAL,CAAgCH,QAAhC,CAAjB;;AACA,WAAKL,QAAL,CAAcS,IAAd,CAAmB;AACfC,QAAAA,QAAQ,EAAEH,QAAQ,CAACI,MAAT,IAAmB,CADd;AAEfR,QAAAA,OAFe;AAGfE,QAAAA,QAHe;AAIfE,QAAAA;AAJe,OAAnB;AAMH;AACJ;;AACDD,EAAAA,mBAAmB,CAACH,OAAD,EAAU;AACzB,UAAMS,KAAK,GAAGnB,KAAK,CAACU,OAAN,CAAcU,eAAd,CAA8BV,OAA9B,EAAuC,KAAKJ,kBAA5C,CAAd;AACA,WAAOa,KAAK,CAACE,GAAN,CAAWC,IAAD,IAAU;AACvB,YAAMC,OAAO,GAAGvB,KAAK,CAACU,OAAN,CAAcc,gBAAd,CAA+BF,IAA/B,EAAqC,KAAKjB,SAA1C,CAAhB;;AACA,UAAI,CAACkB,OAAL,EAAc;AACV,eAAO;AACHA,UAAAA,OAAO,EAAE,KADN;AAEHb,UAAAA,OAAO,EAAEY;AAFN,SAAP;AAIH;;AACD,aAAO;AACHC,QAAAA,OAAO,EAAE,IADN;AAEHb,QAAAA,OAAO,EAAEY,IAFN;AAGHG,QAAAA,SAAS,EAAEzB,KAAK,CAACU,OAAN,CAAcgB,MAAd,CAAqBJ,IAArB,EAA2B,KAAKhB,kBAAhC;AAHR,OAAP;AAKH,KAbM,CAAP;AAcH;;AACDS,EAAAA,0BAA0B,CAACH,QAAD,EAAW;AACjC,WAAOZ,KAAK,CAAC2B,KAAN,CAAYC,SAAZ,CAAsBhB,QAAtB,EAAiCiB,OAAD,IAAaA,OAAO,CAACN,OAAR,IAAmBvB,KAAK,CAACU,OAAN,CAAcoB,WAAd,CAA0BD,OAAO,CAACnB,OAAlC,CAAhE,CAAP;AACH;;AA5CS;;AA8CdZ,OAAO,CAACiC,OAAR,GAAkB7B,OAAlB","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils = require(\"../../utils\");\nclass Matcher {\n    constructor(_patterns, _settings, _micromatchOptions) {\n        this._patterns = _patterns;\n        this._settings = _settings;\n        this._micromatchOptions = _micromatchOptions;\n        this._storage = [];\n        this._fillStorage();\n    }\n    _fillStorage() {\n        /**\n         * The original pattern may include `{,*,**,a/*}`, which will lead to problems with matching (unresolved level).\n         * So, before expand patterns with brace expansion into separated patterns.\n         */\n        const patterns = utils.pattern.expandPatternsWithBraceExpansion(this._patterns);\n        for (const pattern of patterns) {\n            const segments = this._getPatternSegments(pattern);\n            const sections = this._splitSegmentsIntoSections(segments);\n            this._storage.push({\n                complete: sections.length <= 1,\n                pattern,\n                segments,\n                sections\n            });\n        }\n    }\n    _getPatternSegments(pattern) {\n        const parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);\n        return parts.map((part) => {\n            const dynamic = utils.pattern.isDynamicPattern(part, this._settings);\n            if (!dynamic) {\n                return {\n                    dynamic: false,\n                    pattern: part\n                };\n            }\n            return {\n                dynamic: true,\n                pattern: part,\n                patternRe: utils.pattern.makeRe(part, this._micromatchOptions)\n            };\n        });\n    }\n    _splitSegmentsIntoSections(segments) {\n        return utils.array.splitWhen(segments, (segment) => segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));\n    }\n}\nexports.default = Matcher;\n"]},"metadata":{},"sourceType":"script"}