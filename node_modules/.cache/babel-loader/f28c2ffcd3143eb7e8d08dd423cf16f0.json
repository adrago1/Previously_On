{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = expandTailwindAtRules;\n\nvar sharedState = _interopRequireWildcard(require(\"./sharedState\"));\n\nvar _generateRules = require(\"./generateRules\");\n\nvar _bigSign = _interopRequireDefault(require(\"../../util/bigSign\"));\n\nvar _cloneNodes = _interopRequireDefault(require(\"../../util/cloneNodes\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nlet env = sharedState.env;\nlet contentMatchCache = sharedState.contentMatchCache;\nconst PATTERNS = [\"([^<>\\\"'`\\\\s]*\\\\['[^<>\\\"'`\\\\s]*'\\\\])\", // `content-['hello']` but not `content-['hello']']`\n'([^<>\"\\'`\\\\s]*\\\\[\"[^<>\"\\'`\\\\s]*\"\\\\])', // `content-[\"hello\"]` but not `content-[\"hello\"]\"]`\n'([^<>\"\\'`\\\\s]*\\\\[[^<>\"\\'`\\\\s]+\\\\])', // `fill-[#bada55]`\n'([^<>\"\\'`\\\\s]*[^<>\"\\'`\\\\s:])' // `px-1.5`, `uppercase` but not `uppercase:`\n].join('|');\nconst BROAD_MATCH_GLOBAL_REGEXP = new RegExp(PATTERNS, 'g');\nconst INNER_MATCH_GLOBAL_REGEXP = /[^<>\"'`\\s.(){}[\\]#=%]*[^<>\"'`\\s.(){}[\\]#=%:]/g;\nconst builtInExtractors = {\n  DEFAULT: content => {\n    let broadMatches = content.match(BROAD_MATCH_GLOBAL_REGEXP) || [];\n    let innerMatches = content.match(INNER_MATCH_GLOBAL_REGEXP) || [];\n    return [...broadMatches, ...innerMatches];\n  }\n};\nconst builtInTransformers = {\n  DEFAULT: content => content,\n  svelte: content => content.replace(/(?:^|\\s)class:/g, ' ')\n};\n\nfunction getExtractor(tailwindConfig, fileExtension) {\n  let extractors = tailwindConfig && tailwindConfig.purge && tailwindConfig.purge.extract || {};\n  const purgeOptions = tailwindConfig && tailwindConfig.purge && tailwindConfig.purge.options || {};\n\n  if (typeof extractors === 'function') {\n    extractors = {\n      DEFAULT: extractors\n    };\n  }\n\n  if (purgeOptions.defaultExtractor) {\n    extractors.DEFAULT = purgeOptions.defaultExtractor;\n  }\n\n  for (let {\n    extensions,\n    extractor\n  } of purgeOptions.extractors || []) {\n    for (let extension of extensions) {\n      extractors[extension] = extractor;\n    }\n  }\n\n  return extractors[fileExtension] || extractors.DEFAULT || builtInExtractors[fileExtension] || builtInExtractors.DEFAULT;\n}\n\nfunction getTransformer(tailwindConfig, fileExtension) {\n  let transformers = tailwindConfig && tailwindConfig.purge && tailwindConfig.purge.transform || {};\n\n  if (typeof transformers === 'function') {\n    transformers = {\n      DEFAULT: transformers\n    };\n  }\n\n  return transformers[fileExtension] || transformers.DEFAULT || builtInTransformers[fileExtension] || builtInTransformers.DEFAULT;\n} // Scans template contents for possible classes. This is a hot path on initial build but\n// not too important for subsequent builds. The faster the better though — if we can speed\n// up these regexes by 50% that could cut initial build time by like 20%.\n\n\nfunction getClassCandidates(content, extractor, contentMatchCache, candidates, seen) {\n  for (let line of content.split('\\n')) {\n    line = line.trim();\n\n    if (seen.has(line)) {\n      continue;\n    }\n\n    seen.add(line);\n\n    if (contentMatchCache.has(line)) {\n      for (let match of contentMatchCache.get(line)) {\n        candidates.add(match);\n      }\n    } else {\n      let extractorMatches = extractor(line).filter(s => s !== '!*');\n      let lineMatchesSet = new Set(extractorMatches);\n\n      for (let match of lineMatchesSet) {\n        candidates.add(match);\n      }\n\n      contentMatchCache.set(line, lineMatchesSet);\n    }\n  }\n}\n\nfunction buildStylesheet(rules, context) {\n  let sortedRules = rules.sort(([a], [z]) => (0, _bigSign.default)(a - z));\n  let returnValue = {\n    base: new Set(),\n    components: new Set(),\n    utilities: new Set(),\n    variants: new Set()\n  };\n\n  for (let [sort, rule] of sortedRules) {\n    if (sort >= context.minimumScreen) {\n      returnValue.variants.add(rule);\n      continue;\n    }\n\n    if (sort & context.layerOrder.base) {\n      returnValue.base.add(rule);\n      continue;\n    }\n\n    if (sort & context.layerOrder.components) {\n      returnValue.components.add(rule);\n      continue;\n    }\n\n    if (sort & context.layerOrder.utilities) {\n      returnValue.utilities.add(rule);\n      continue;\n    }\n  }\n\n  return returnValue;\n}\n\nfunction expandTailwindAtRules(context) {\n  return root => {\n    let layerNodes = {\n      base: null,\n      components: null,\n      utilities: null,\n      variants: null\n    }; // Make sure this file contains Tailwind directives. If not, we can save\n    // a lot of work and bail early. Also we don't have to register our touch\n    // file as a dependency since the output of this CSS does not depend on\n    // the source of any templates. Think Vue <style> blocks for example.\n\n    root.walkAtRules('tailwind', rule => {\n      if (Object.keys(layerNodes).includes(rule.params)) {\n        layerNodes[rule.params] = rule;\n      }\n    });\n\n    if (Object.values(layerNodes).every(n => n === null)) {\n      return root;\n    } // ---\n    // Find potential rules in changed files\n\n\n    let candidates = new Set(['*']);\n    let seen = new Set();\n    env.DEBUG && console.time('Reading changed files');\n\n    for (let {\n      content,\n      extension\n    } of context.changedContent) {\n      let transformer = getTransformer(context.tailwindConfig, extension);\n      let extractor = getExtractor(context.tailwindConfig, extension);\n      getClassCandidates(transformer(content), extractor, contentMatchCache, candidates, seen);\n    } // ---\n    // Generate the actual CSS\n\n\n    let classCacheCount = context.classCache.size;\n    env.DEBUG && console.time('Generate rules');\n    let rules = (0, _generateRules.generateRules)(candidates, context);\n    env.DEBUG && console.timeEnd('Generate rules'); // We only ever add to the classCache, so if it didn't grow, there is nothing new.\n\n    env.DEBUG && console.time('Build stylesheet');\n\n    if (context.stylesheetCache === null || context.classCache.size !== classCacheCount) {\n      for (let rule of rules) {\n        context.ruleCache.add(rule);\n      }\n\n      context.stylesheetCache = buildStylesheet([...context.ruleCache], context);\n    }\n\n    env.DEBUG && console.timeEnd('Build stylesheet');\n    let {\n      base: baseNodes,\n      components: componentNodes,\n      utilities: utilityNodes,\n      variants: screenNodes\n    } = context.stylesheetCache; // ---\n    // Replace any Tailwind directives with generated CSS\n\n    if (layerNodes.base) {\n      layerNodes.base.before((0, _cloneNodes.default)([...baseNodes], layerNodes.base.source));\n      layerNodes.base.remove();\n    }\n\n    if (layerNodes.components) {\n      layerNodes.components.before((0, _cloneNodes.default)([...componentNodes], layerNodes.components.source));\n      layerNodes.components.remove();\n    }\n\n    if (layerNodes.utilities) {\n      layerNodes.utilities.before((0, _cloneNodes.default)([...utilityNodes], layerNodes.utilities.source));\n      layerNodes.utilities.remove();\n    }\n\n    if (layerNodes.variants) {\n      layerNodes.variants.before((0, _cloneNodes.default)([...screenNodes], layerNodes.variants.source));\n      layerNodes.variants.remove();\n    } else {\n      root.append((0, _cloneNodes.default)([...screenNodes], root.source));\n    } // ---\n\n\n    if (env.DEBUG) {\n      console.log('Potential classes: ', candidates.size);\n      console.log('Active contexts: ', sharedState.contextSourcesMap.size);\n      console.log('Content match entries', contentMatchCache.size);\n    } // Clear the cache for the changed files\n\n\n    context.changedContent = []; // Cleanup any leftover @layer atrules\n\n    root.walkAtRules('layer', rule => {\n      if (Object.keys(layerNodes).includes(rule.params)) {\n        rule.remove();\n      }\n    });\n  };\n}","map":{"version":3,"sources":["/home/alan/delivery_2/previously_on/client/node_modules/tailwindcss/lib/jit/lib/expandTailwindAtRules.js"],"names":["Object","defineProperty","exports","value","default","expandTailwindAtRules","sharedState","_interopRequireWildcard","require","_generateRules","_bigSign","_interopRequireDefault","_cloneNodes","obj","__esModule","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","env","contentMatchCache","PATTERNS","join","BROAD_MATCH_GLOBAL_REGEXP","RegExp","INNER_MATCH_GLOBAL_REGEXP","builtInExtractors","DEFAULT","content","broadMatches","match","innerMatches","builtInTransformers","svelte","replace","getExtractor","tailwindConfig","fileExtension","extractors","purge","extract","purgeOptions","options","defaultExtractor","extensions","extractor","extension","getTransformer","transformers","transform","getClassCandidates","candidates","seen","line","split","trim","add","extractorMatches","filter","s","lineMatchesSet","Set","buildStylesheet","rules","context","sortedRules","sort","a","z","returnValue","base","components","utilities","variants","rule","minimumScreen","layerOrder","root","layerNodes","walkAtRules","keys","includes","params","values","every","n","DEBUG","console","time","changedContent","transformer","classCacheCount","classCache","size","generateRules","timeEnd","stylesheetCache","ruleCache","baseNodes","componentNodes","utilityNodes","screenNodes","before","source","remove","append","log","contextSourcesMap"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = expandTailwindAtRules;\n\nvar sharedState = _interopRequireWildcard(require(\"./sharedState\"));\n\nvar _generateRules = require(\"./generateRules\");\n\nvar _bigSign = _interopRequireDefault(require(\"../../util/bigSign\"));\n\nvar _cloneNodes = _interopRequireDefault(require(\"../../util/cloneNodes\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nlet env = sharedState.env;\nlet contentMatchCache = sharedState.contentMatchCache;\nconst PATTERNS = [\"([^<>\\\"'`\\\\s]*\\\\['[^<>\\\"'`\\\\s]*'\\\\])\", // `content-['hello']` but not `content-['hello']']`\n'([^<>\"\\'`\\\\s]*\\\\[\"[^<>\"\\'`\\\\s]*\"\\\\])', // `content-[\"hello\"]` but not `content-[\"hello\"]\"]`\n'([^<>\"\\'`\\\\s]*\\\\[[^<>\"\\'`\\\\s]+\\\\])', // `fill-[#bada55]`\n'([^<>\"\\'`\\\\s]*[^<>\"\\'`\\\\s:])' // `px-1.5`, `uppercase` but not `uppercase:`\n].join('|');\nconst BROAD_MATCH_GLOBAL_REGEXP = new RegExp(PATTERNS, 'g');\nconst INNER_MATCH_GLOBAL_REGEXP = /[^<>\"'`\\s.(){}[\\]#=%]*[^<>\"'`\\s.(){}[\\]#=%:]/g;\nconst builtInExtractors = {\n  DEFAULT: content => {\n    let broadMatches = content.match(BROAD_MATCH_GLOBAL_REGEXP) || [];\n    let innerMatches = content.match(INNER_MATCH_GLOBAL_REGEXP) || [];\n    return [...broadMatches, ...innerMatches];\n  }\n};\nconst builtInTransformers = {\n  DEFAULT: content => content,\n  svelte: content => content.replace(/(?:^|\\s)class:/g, ' ')\n};\n\nfunction getExtractor(tailwindConfig, fileExtension) {\n  let extractors = tailwindConfig && tailwindConfig.purge && tailwindConfig.purge.extract || {};\n  const purgeOptions = tailwindConfig && tailwindConfig.purge && tailwindConfig.purge.options || {};\n\n  if (typeof extractors === 'function') {\n    extractors = {\n      DEFAULT: extractors\n    };\n  }\n\n  if (purgeOptions.defaultExtractor) {\n    extractors.DEFAULT = purgeOptions.defaultExtractor;\n  }\n\n  for (let {\n    extensions,\n    extractor\n  } of purgeOptions.extractors || []) {\n    for (let extension of extensions) {\n      extractors[extension] = extractor;\n    }\n  }\n\n  return extractors[fileExtension] || extractors.DEFAULT || builtInExtractors[fileExtension] || builtInExtractors.DEFAULT;\n}\n\nfunction getTransformer(tailwindConfig, fileExtension) {\n  let transformers = tailwindConfig && tailwindConfig.purge && tailwindConfig.purge.transform || {};\n\n  if (typeof transformers === 'function') {\n    transformers = {\n      DEFAULT: transformers\n    };\n  }\n\n  return transformers[fileExtension] || transformers.DEFAULT || builtInTransformers[fileExtension] || builtInTransformers.DEFAULT;\n} // Scans template contents for possible classes. This is a hot path on initial build but\n// not too important for subsequent builds. The faster the better though — if we can speed\n// up these regexes by 50% that could cut initial build time by like 20%.\n\n\nfunction getClassCandidates(content, extractor, contentMatchCache, candidates, seen) {\n  for (let line of content.split('\\n')) {\n    line = line.trim();\n\n    if (seen.has(line)) {\n      continue;\n    }\n\n    seen.add(line);\n\n    if (contentMatchCache.has(line)) {\n      for (let match of contentMatchCache.get(line)) {\n        candidates.add(match);\n      }\n    } else {\n      let extractorMatches = extractor(line).filter(s => s !== '!*');\n      let lineMatchesSet = new Set(extractorMatches);\n\n      for (let match of lineMatchesSet) {\n        candidates.add(match);\n      }\n\n      contentMatchCache.set(line, lineMatchesSet);\n    }\n  }\n}\n\nfunction buildStylesheet(rules, context) {\n  let sortedRules = rules.sort(([a], [z]) => (0, _bigSign.default)(a - z));\n  let returnValue = {\n    base: new Set(),\n    components: new Set(),\n    utilities: new Set(),\n    variants: new Set()\n  };\n\n  for (let [sort, rule] of sortedRules) {\n    if (sort >= context.minimumScreen) {\n      returnValue.variants.add(rule);\n      continue;\n    }\n\n    if (sort & context.layerOrder.base) {\n      returnValue.base.add(rule);\n      continue;\n    }\n\n    if (sort & context.layerOrder.components) {\n      returnValue.components.add(rule);\n      continue;\n    }\n\n    if (sort & context.layerOrder.utilities) {\n      returnValue.utilities.add(rule);\n      continue;\n    }\n  }\n\n  return returnValue;\n}\n\nfunction expandTailwindAtRules(context) {\n  return root => {\n    let layerNodes = {\n      base: null,\n      components: null,\n      utilities: null,\n      variants: null\n    }; // Make sure this file contains Tailwind directives. If not, we can save\n    // a lot of work and bail early. Also we don't have to register our touch\n    // file as a dependency since the output of this CSS does not depend on\n    // the source of any templates. Think Vue <style> blocks for example.\n\n    root.walkAtRules('tailwind', rule => {\n      if (Object.keys(layerNodes).includes(rule.params)) {\n        layerNodes[rule.params] = rule;\n      }\n    });\n\n    if (Object.values(layerNodes).every(n => n === null)) {\n      return root;\n    } // ---\n    // Find potential rules in changed files\n\n\n    let candidates = new Set(['*']);\n    let seen = new Set();\n    env.DEBUG && console.time('Reading changed files');\n\n    for (let {\n      content,\n      extension\n    } of context.changedContent) {\n      let transformer = getTransformer(context.tailwindConfig, extension);\n      let extractor = getExtractor(context.tailwindConfig, extension);\n      getClassCandidates(transformer(content), extractor, contentMatchCache, candidates, seen);\n    } // ---\n    // Generate the actual CSS\n\n\n    let classCacheCount = context.classCache.size;\n    env.DEBUG && console.time('Generate rules');\n    let rules = (0, _generateRules.generateRules)(candidates, context);\n    env.DEBUG && console.timeEnd('Generate rules'); // We only ever add to the classCache, so if it didn't grow, there is nothing new.\n\n    env.DEBUG && console.time('Build stylesheet');\n\n    if (context.stylesheetCache === null || context.classCache.size !== classCacheCount) {\n      for (let rule of rules) {\n        context.ruleCache.add(rule);\n      }\n\n      context.stylesheetCache = buildStylesheet([...context.ruleCache], context);\n    }\n\n    env.DEBUG && console.timeEnd('Build stylesheet');\n    let {\n      base: baseNodes,\n      components: componentNodes,\n      utilities: utilityNodes,\n      variants: screenNodes\n    } = context.stylesheetCache; // ---\n    // Replace any Tailwind directives with generated CSS\n\n    if (layerNodes.base) {\n      layerNodes.base.before((0, _cloneNodes.default)([...baseNodes], layerNodes.base.source));\n      layerNodes.base.remove();\n    }\n\n    if (layerNodes.components) {\n      layerNodes.components.before((0, _cloneNodes.default)([...componentNodes], layerNodes.components.source));\n      layerNodes.components.remove();\n    }\n\n    if (layerNodes.utilities) {\n      layerNodes.utilities.before((0, _cloneNodes.default)([...utilityNodes], layerNodes.utilities.source));\n      layerNodes.utilities.remove();\n    }\n\n    if (layerNodes.variants) {\n      layerNodes.variants.before((0, _cloneNodes.default)([...screenNodes], layerNodes.variants.source));\n      layerNodes.variants.remove();\n    } else {\n      root.append((0, _cloneNodes.default)([...screenNodes], root.source));\n    } // ---\n\n\n    if (env.DEBUG) {\n      console.log('Potential classes: ', candidates.size);\n      console.log('Active contexts: ', sharedState.contextSourcesMap.size);\n      console.log('Content match entries', contentMatchCache.size);\n    } // Clear the cache for the changed files\n\n\n    context.changedContent = []; // Cleanup any leftover @layer atrules\n\n    root.walkAtRules('layer', rule => {\n      if (Object.keys(layerNodes).includes(rule.params)) {\n        rule.remove();\n      }\n    });\n  };\n}"]},"metadata":{},"sourceType":"script"}