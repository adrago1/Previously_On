{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = setupTrackingContext;\n\nvar _fs = _interopRequireDefault(require(\"fs\"));\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _fastGlob = _interopRequireDefault(require(\"fast-glob\"));\n\nvar _quickLru = _interopRequireDefault(require(\"quick-lru\"));\n\nvar _normalizePath = _interopRequireDefault(require(\"normalize-path\"));\n\nvar _hashConfig = _interopRequireDefault(require(\"../../util/hashConfig\"));\n\nvar _getModuleDependencies = _interopRequireDefault(require(\"../../lib/getModuleDependencies\"));\n\nvar _resolveConfig = _interopRequireDefault(require(\"../../../resolveConfig\"));\n\nvar _resolveConfigPath = _interopRequireDefault(require(\"../../util/resolveConfigPath\"));\n\nvar _sharedState = require(\"./sharedState\");\n\nvar _setupContextUtils = require(\"./setupContextUtils\");\n\nvar _parseDependency = _interopRequireDefault(require(\"../../util/parseDependency\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nlet configPathCache = new _quickLru.default({\n  maxSize: 100\n});\nlet candidateFilesCache = new WeakMap();\n\nfunction getCandidateFiles(context, tailwindConfig) {\n  if (candidateFilesCache.has(context)) {\n    return candidateFilesCache.get(context);\n  }\n\n  let purgeContent = Array.isArray(tailwindConfig.purge) ? tailwindConfig.purge : tailwindConfig.purge.content;\n  let candidateFiles = purgeContent.filter(item => typeof item === 'string').map(purgePath => (0, _normalizePath.default)(_path.default.resolve(purgePath)));\n  return candidateFilesCache.set(context, candidateFiles).get(context);\n} // Get the config object based on a path\n\n\nfunction getTailwindConfig(configOrPath) {\n  let userConfigPath = (0, _resolveConfigPath.default)(configOrPath);\n\n  if (userConfigPath !== null) {\n    let [prevConfig, prevConfigHash, prevDeps, prevModified] = configPathCache.get(userConfigPath) || [];\n    let newDeps = (0, _getModuleDependencies.default)(userConfigPath).map(dep => dep.file);\n    let modified = false;\n    let newModified = new Map();\n\n    for (let file of newDeps) {\n      let time = _fs.default.statSync(file).mtimeMs;\n\n      newModified.set(file, time);\n\n      if (!prevModified || !prevModified.has(file) || time > prevModified.get(file)) {\n        modified = true;\n      }\n    } // It hasn't changed (based on timestamps)\n\n\n    if (!modified) {\n      return [prevConfig, userConfigPath, prevConfigHash, prevDeps];\n    } // It has changed (based on timestamps), or first run\n\n\n    for (let file of newDeps) {\n      delete require.cache[file];\n    }\n\n    let newConfig = (0, _resolveConfig.default)(require(userConfigPath));\n    let newHash = (0, _hashConfig.default)(newConfig);\n    configPathCache.set(userConfigPath, [newConfig, newHash, newDeps, newModified]);\n    return [newConfig, userConfigPath, newHash, newDeps];\n  } // It's a plain object, not a path\n\n\n  let newConfig = (0, _resolveConfig.default)(configOrPath.config === undefined ? configOrPath : configOrPath.config);\n  return [newConfig, null, (0, _hashConfig.default)(newConfig), []];\n}\n\nfunction resolvedChangedContent(context, candidateFiles, fileModifiedMap) {\n  var _context$tailwindConf, _context$tailwindConf2;\n\n  let changedContent = (Array.isArray(context.tailwindConfig.purge) ? context.tailwindConfig.purge : context.tailwindConfig.purge.content).filter(item => typeof item.raw === 'string').concat(((_context$tailwindConf = (_context$tailwindConf2 = context.tailwindConfig.purge) === null || _context$tailwindConf2 === void 0 ? void 0 : _context$tailwindConf2.safelist) !== null && _context$tailwindConf !== void 0 ? _context$tailwindConf : []).map(content => {\n    if (typeof content === 'string') {\n      return {\n        raw: content,\n        extension: 'html'\n      };\n    }\n\n    if (content instanceof RegExp) {\n      throw new Error(\"Values inside 'purge.safelist' can only be of type 'string', found 'regex'.\");\n    }\n\n    throw new Error(`Values inside 'purge.safelist' can only be of type 'string', found '${typeof content}'.`);\n  })).map(({\n    raw,\n    extension\n  }) => ({\n    content: raw,\n    extension\n  }));\n\n  for (let changedFile of resolveChangedFiles(candidateFiles, fileModifiedMap)) {\n    let content = _fs.default.readFileSync(changedFile, 'utf8');\n\n    let extension = _path.default.extname(changedFile).slice(1);\n\n    changedContent.push({\n      content,\n      extension\n    });\n  }\n\n  return changedContent;\n}\n\nfunction resolveChangedFiles(candidateFiles, fileModifiedMap) {\n  let changedFiles = new Set();\n  _sharedState.env.DEBUG && console.time('Finding changed files');\n\n  let files = _fastGlob.default.sync(candidateFiles);\n\n  for (let file of files) {\n    let prevModified = fileModifiedMap.has(file) ? fileModifiedMap.get(file) : -Infinity;\n\n    let modified = _fs.default.statSync(file).mtimeMs;\n\n    if (modified > prevModified) {\n      changedFiles.add(file);\n      fileModifiedMap.set(file, modified);\n    }\n  }\n\n  _sharedState.env.DEBUG && console.timeEnd('Finding changed files');\n  return changedFiles;\n} // DISABLE_TOUCH = TRUE\n// Retrieve an existing context from cache if possible (since contexts are unique per\n// source path), or set up a new one (including setting up watchers and registering\n// plugins) then return it\n\n\nfunction setupTrackingContext(configOrPath) {\n  return ({\n    tailwindDirectives,\n    registerDependency\n  }) => {\n    return (root, result) => {\n      let [tailwindConfig, userConfigPath, tailwindConfigHash, configDependencies] = getTailwindConfig(configOrPath);\n      let contextDependencies = new Set(configDependencies); // If there are no @tailwind rules, we don't consider this CSS file or it's dependencies\n      // to be dependencies of the context. Can reuse the context even if they change.\n      // We may want to think about `@layer` being part of this trigger too, but it's tough\n      // because it's impossible for a layer in one file to end up in the actual @tailwind rule\n      // in another file since independent sources are effectively isolated.\n\n      if (tailwindDirectives.size > 0) {\n        // Add current css file as a context dependencies.\n        contextDependencies.add(result.opts.from); // Add all css @import dependencies as context dependencies.\n\n        for (let message of result.messages) {\n          if (message.type === 'dependency') {\n            contextDependencies.add(message.file);\n          }\n        }\n      }\n\n      let [context] = (0, _setupContextUtils.getContext)(tailwindDirectives, root, result, tailwindConfig, userConfigPath, tailwindConfigHash, contextDependencies);\n      let candidateFiles = getCandidateFiles(context, tailwindConfig); // If there are no @tailwind rules, we don't consider this CSS file or it's dependencies\n      // to be dependencies of the context. Can reuse the context even if they change.\n      // We may want to think about `@layer` being part of this trigger too, but it's tough\n      // because it's impossible for a layer in one file to end up in the actual @tailwind rule\n      // in another file since independent sources are effectively isolated.\n\n      if (tailwindDirectives.size > 0) {\n        let fileModifiedMap = (0, _setupContextUtils.getFileModifiedMap)(context); // Add template paths as postcss dependencies.\n\n        for (let fileOrGlob of candidateFiles) {\n          registerDependency((0, _parseDependency.default)(fileOrGlob));\n        }\n\n        for (let changedContent of resolvedChangedContent(context, candidateFiles, fileModifiedMap)) {\n          context.changedContent.push(changedContent);\n        }\n      }\n\n      for (let file of configDependencies) {\n        registerDependency({\n          type: 'dependency',\n          file\n        });\n      }\n\n      return context;\n    };\n  };\n}","map":{"version":3,"sources":["/home/alan/delivery_2/previously_on/client/node_modules/tailwindcss/lib/jit/lib/setupTrackingContext.js"],"names":["Object","defineProperty","exports","value","default","setupTrackingContext","_fs","_interopRequireDefault","require","_path","_fastGlob","_quickLru","_normalizePath","_hashConfig","_getModuleDependencies","_resolveConfig","_resolveConfigPath","_sharedState","_setupContextUtils","_parseDependency","obj","__esModule","configPathCache","maxSize","candidateFilesCache","WeakMap","getCandidateFiles","context","tailwindConfig","has","get","purgeContent","Array","isArray","purge","content","candidateFiles","filter","item","map","purgePath","resolve","set","getTailwindConfig","configOrPath","userConfigPath","prevConfig","prevConfigHash","prevDeps","prevModified","newDeps","dep","file","modified","newModified","Map","time","statSync","mtimeMs","cache","newConfig","newHash","config","undefined","resolvedChangedContent","fileModifiedMap","_context$tailwindConf","_context$tailwindConf2","changedContent","raw","concat","safelist","extension","RegExp","Error","changedFile","resolveChangedFiles","readFileSync","extname","slice","push","changedFiles","Set","env","DEBUG","console","files","sync","Infinity","add","timeEnd","tailwindDirectives","registerDependency","root","result","tailwindConfigHash","configDependencies","contextDependencies","size","opts","from","message","messages","type","getContext","getFileModifiedMap","fileOrGlob"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = setupTrackingContext;\n\nvar _fs = _interopRequireDefault(require(\"fs\"));\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _fastGlob = _interopRequireDefault(require(\"fast-glob\"));\n\nvar _quickLru = _interopRequireDefault(require(\"quick-lru\"));\n\nvar _normalizePath = _interopRequireDefault(require(\"normalize-path\"));\n\nvar _hashConfig = _interopRequireDefault(require(\"../../util/hashConfig\"));\n\nvar _getModuleDependencies = _interopRequireDefault(require(\"../../lib/getModuleDependencies\"));\n\nvar _resolveConfig = _interopRequireDefault(require(\"../../../resolveConfig\"));\n\nvar _resolveConfigPath = _interopRequireDefault(require(\"../../util/resolveConfigPath\"));\n\nvar _sharedState = require(\"./sharedState\");\n\nvar _setupContextUtils = require(\"./setupContextUtils\");\n\nvar _parseDependency = _interopRequireDefault(require(\"../../util/parseDependency\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nlet configPathCache = new _quickLru.default({\n  maxSize: 100\n});\nlet candidateFilesCache = new WeakMap();\n\nfunction getCandidateFiles(context, tailwindConfig) {\n  if (candidateFilesCache.has(context)) {\n    return candidateFilesCache.get(context);\n  }\n\n  let purgeContent = Array.isArray(tailwindConfig.purge) ? tailwindConfig.purge : tailwindConfig.purge.content;\n  let candidateFiles = purgeContent.filter(item => typeof item === 'string').map(purgePath => (0, _normalizePath.default)(_path.default.resolve(purgePath)));\n  return candidateFilesCache.set(context, candidateFiles).get(context);\n} // Get the config object based on a path\n\n\nfunction getTailwindConfig(configOrPath) {\n  let userConfigPath = (0, _resolveConfigPath.default)(configOrPath);\n\n  if (userConfigPath !== null) {\n    let [prevConfig, prevConfigHash, prevDeps, prevModified] = configPathCache.get(userConfigPath) || [];\n    let newDeps = (0, _getModuleDependencies.default)(userConfigPath).map(dep => dep.file);\n    let modified = false;\n    let newModified = new Map();\n\n    for (let file of newDeps) {\n      let time = _fs.default.statSync(file).mtimeMs;\n\n      newModified.set(file, time);\n\n      if (!prevModified || !prevModified.has(file) || time > prevModified.get(file)) {\n        modified = true;\n      }\n    } // It hasn't changed (based on timestamps)\n\n\n    if (!modified) {\n      return [prevConfig, userConfigPath, prevConfigHash, prevDeps];\n    } // It has changed (based on timestamps), or first run\n\n\n    for (let file of newDeps) {\n      delete require.cache[file];\n    }\n\n    let newConfig = (0, _resolveConfig.default)(require(userConfigPath));\n    let newHash = (0, _hashConfig.default)(newConfig);\n    configPathCache.set(userConfigPath, [newConfig, newHash, newDeps, newModified]);\n    return [newConfig, userConfigPath, newHash, newDeps];\n  } // It's a plain object, not a path\n\n\n  let newConfig = (0, _resolveConfig.default)(configOrPath.config === undefined ? configOrPath : configOrPath.config);\n  return [newConfig, null, (0, _hashConfig.default)(newConfig), []];\n}\n\nfunction resolvedChangedContent(context, candidateFiles, fileModifiedMap) {\n  var _context$tailwindConf, _context$tailwindConf2;\n\n  let changedContent = (Array.isArray(context.tailwindConfig.purge) ? context.tailwindConfig.purge : context.tailwindConfig.purge.content).filter(item => typeof item.raw === 'string').concat(((_context$tailwindConf = (_context$tailwindConf2 = context.tailwindConfig.purge) === null || _context$tailwindConf2 === void 0 ? void 0 : _context$tailwindConf2.safelist) !== null && _context$tailwindConf !== void 0 ? _context$tailwindConf : []).map(content => {\n    if (typeof content === 'string') {\n      return {\n        raw: content,\n        extension: 'html'\n      };\n    }\n\n    if (content instanceof RegExp) {\n      throw new Error(\"Values inside 'purge.safelist' can only be of type 'string', found 'regex'.\");\n    }\n\n    throw new Error(`Values inside 'purge.safelist' can only be of type 'string', found '${typeof content}'.`);\n  })).map(({\n    raw,\n    extension\n  }) => ({\n    content: raw,\n    extension\n  }));\n\n  for (let changedFile of resolveChangedFiles(candidateFiles, fileModifiedMap)) {\n    let content = _fs.default.readFileSync(changedFile, 'utf8');\n\n    let extension = _path.default.extname(changedFile).slice(1);\n\n    changedContent.push({\n      content,\n      extension\n    });\n  }\n\n  return changedContent;\n}\n\nfunction resolveChangedFiles(candidateFiles, fileModifiedMap) {\n  let changedFiles = new Set();\n  _sharedState.env.DEBUG && console.time('Finding changed files');\n\n  let files = _fastGlob.default.sync(candidateFiles);\n\n  for (let file of files) {\n    let prevModified = fileModifiedMap.has(file) ? fileModifiedMap.get(file) : -Infinity;\n\n    let modified = _fs.default.statSync(file).mtimeMs;\n\n    if (modified > prevModified) {\n      changedFiles.add(file);\n      fileModifiedMap.set(file, modified);\n    }\n  }\n\n  _sharedState.env.DEBUG && console.timeEnd('Finding changed files');\n  return changedFiles;\n} // DISABLE_TOUCH = TRUE\n// Retrieve an existing context from cache if possible (since contexts are unique per\n// source path), or set up a new one (including setting up watchers and registering\n// plugins) then return it\n\n\nfunction setupTrackingContext(configOrPath) {\n  return ({\n    tailwindDirectives,\n    registerDependency\n  }) => {\n    return (root, result) => {\n      let [tailwindConfig, userConfigPath, tailwindConfigHash, configDependencies] = getTailwindConfig(configOrPath);\n      let contextDependencies = new Set(configDependencies); // If there are no @tailwind rules, we don't consider this CSS file or it's dependencies\n      // to be dependencies of the context. Can reuse the context even if they change.\n      // We may want to think about `@layer` being part of this trigger too, but it's tough\n      // because it's impossible for a layer in one file to end up in the actual @tailwind rule\n      // in another file since independent sources are effectively isolated.\n\n      if (tailwindDirectives.size > 0) {\n        // Add current css file as a context dependencies.\n        contextDependencies.add(result.opts.from); // Add all css @import dependencies as context dependencies.\n\n        for (let message of result.messages) {\n          if (message.type === 'dependency') {\n            contextDependencies.add(message.file);\n          }\n        }\n      }\n\n      let [context] = (0, _setupContextUtils.getContext)(tailwindDirectives, root, result, tailwindConfig, userConfigPath, tailwindConfigHash, contextDependencies);\n      let candidateFiles = getCandidateFiles(context, tailwindConfig); // If there are no @tailwind rules, we don't consider this CSS file or it's dependencies\n      // to be dependencies of the context. Can reuse the context even if they change.\n      // We may want to think about `@layer` being part of this trigger too, but it's tough\n      // because it's impossible for a layer in one file to end up in the actual @tailwind rule\n      // in another file since independent sources are effectively isolated.\n\n      if (tailwindDirectives.size > 0) {\n        let fileModifiedMap = (0, _setupContextUtils.getFileModifiedMap)(context); // Add template paths as postcss dependencies.\n\n        for (let fileOrGlob of candidateFiles) {\n          registerDependency((0, _parseDependency.default)(fileOrGlob));\n        }\n\n        for (let changedContent of resolvedChangedContent(context, candidateFiles, fileModifiedMap)) {\n          context.changedContent.push(changedContent);\n        }\n      }\n\n      for (let file of configDependencies) {\n        registerDependency({\n          type: 'dependency',\n          file\n        });\n      }\n\n      return context;\n    };\n  };\n}"]},"metadata":{},"sourceType":"script"}