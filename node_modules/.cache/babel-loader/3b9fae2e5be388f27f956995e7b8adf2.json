{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = expandApplyAtRules;\n\nvar _postcss = _interopRequireDefault(require(\"postcss\"));\n\nvar _generateRules = require(\"./generateRules\");\n\nvar _bigSign = _interopRequireDefault(require(\"../../util/bigSign\"));\n\nvar _escapeClassName = _interopRequireDefault(require(\"../../util/escapeClassName\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction buildApplyCache(applyCandidates, context) {\n  for (let candidate of applyCandidates) {\n    if (context.notClassCache.has(candidate) || context.applyClassCache.has(candidate)) {\n      continue;\n    }\n\n    if (context.classCache.has(candidate)) {\n      context.applyClassCache.set(candidate, context.classCache.get(candidate).map(([meta, rule]) => [meta, rule.clone()]));\n      continue;\n    }\n\n    let matches = Array.from((0, _generateRules.resolveMatches)(candidate, context));\n\n    if (matches.length === 0) {\n      context.notClassCache.add(candidate);\n      continue;\n    }\n\n    context.applyClassCache.set(candidate, matches);\n  }\n\n  return context.applyClassCache;\n}\n\nfunction extractApplyCandidates(params) {\n  let candidates = params.split(/[\\s\\t\\n]+/g);\n\n  if (candidates[candidates.length - 1] === '!important') {\n    return [candidates.slice(0, -1), true];\n  }\n\n  return [candidates, false];\n}\n\nfunction partitionApplyParents(root) {\n  let applyParents = new Set();\n  root.walkAtRules('apply', rule => {\n    applyParents.add(rule.parent);\n  });\n\n  for (let rule of applyParents) {\n    let nodeGroups = [];\n    let lastGroup = [];\n\n    for (let node of rule.nodes) {\n      if (node.type === 'atrule' && node.name === 'apply') {\n        if (lastGroup.length > 0) {\n          nodeGroups.push(lastGroup);\n          lastGroup = [];\n        }\n\n        nodeGroups.push([node]);\n      } else {\n        lastGroup.push(node);\n      }\n    }\n\n    if (lastGroup.length > 0) {\n      nodeGroups.push(lastGroup);\n    }\n\n    if (nodeGroups.length === 1) {\n      continue;\n    }\n\n    for (let group of [...nodeGroups].reverse()) {\n      let newParent = rule.clone({\n        nodes: []\n      });\n      newParent.append(group);\n      rule.after(newParent);\n    }\n\n    rule.remove();\n  }\n}\n\nfunction processApply(root, context) {\n  let applyCandidates = new Set(); // Collect all @apply rules and candidates\n\n  let applies = [];\n  root.walkAtRules('apply', rule => {\n    let [candidates] = extractApplyCandidates(rule.params);\n\n    for (let util of candidates) {\n      applyCandidates.add(util);\n    }\n\n    applies.push(rule);\n  }); // Start the @apply process if we have rules with @apply in them\n\n  if (applies.length > 0) {\n    // Fill up some caches!\n    let applyClassCache = buildApplyCache(applyCandidates, context);\n    /**\n     * When we have an apply like this:\n     *\n     * .abc {\n     *    @apply hover:font-bold;\n     * }\n     *\n     * What we essentially will do is resolve to this:\n     *\n     * .abc {\n     *    @apply .hover\\:font-bold:hover {\n     *      font-weight: 500;\n     *    }\n     * }\n     *\n     * Notice that the to-be-applied class is `.hover\\:font-bold:hover` and that the utility candidate was `hover:font-bold`.\n     * What happens in this function is that we prepend a `.` and escape the candidate.\n     * This will result in `.hover\\:font-bold`\n     * Which means that we can replace `.hover\\:font-bold` with `.abc` in `.hover\\:font-bold:hover` resulting in `.abc:hover`\n     */\n    // TODO: Should we use postcss-selector-parser for this instead?\n\n    function replaceSelector(selector, utilitySelectors, candidate) {\n      let needle = `.${(0, _escapeClassName.default)(candidate)}`;\n      let utilitySelectorsList = utilitySelectors.split(/\\s*,\\s*/g);\n      return selector.split(/\\s*,\\s*/g).map(s => {\n        let replaced = [];\n\n        for (let utilitySelector of utilitySelectorsList) {\n          let replacedSelector = utilitySelector.replace(needle, s);\n\n          if (replacedSelector === utilitySelector) {\n            continue;\n          }\n\n          replaced.push(replacedSelector);\n        }\n\n        return replaced.join(', ');\n      }).join(', ');\n    }\n\n    let perParentApplies = new Map(); // Collect all apply candidates and their rules\n\n    for (let apply of applies) {\n      let candidates = perParentApplies.get(apply.parent) || [];\n      perParentApplies.set(apply.parent, candidates);\n      let [applyCandidates, important] = extractApplyCandidates(apply.params);\n\n      if (apply.parent.type === 'atrule') {\n        if (apply.parent.name === 'screen') {\n          const screenType = apply.parent.params;\n          throw apply.error(`@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply ${applyCandidates.map(c => `${screenType}:${c}`).join(' ')} instead.`);\n        }\n\n        throw apply.error(`@apply is not supported within nested at-rules like @${apply.parent.name}. You can fix this by un-nesting @${apply.parent.name}.`);\n      }\n\n      for (let applyCandidate of applyCandidates) {\n        if (!applyClassCache.has(applyCandidate)) {\n          throw apply.error(`The \\`${applyCandidate}\\` class does not exist. If \\`${applyCandidate}\\` is a custom class, make sure it is defined within a \\`@layer\\` directive.`);\n        }\n\n        let rules = applyClassCache.get(applyCandidate);\n        candidates.push([applyCandidate, important, rules]);\n      }\n    }\n\n    for (const [parent, candidates] of perParentApplies) {\n      let siblings = [];\n\n      for (let [applyCandidate, important, rules] of candidates) {\n        for (let [meta, node] of rules) {\n          let root = _postcss.default.root({\n            nodes: [node.clone()]\n          });\n\n          let canRewriteSelector = node.type !== 'atrule' || node.type === 'atrule' && node.name !== 'keyframes';\n\n          if (canRewriteSelector) {\n            root.walkRules(rule => {\n              rule.selector = replaceSelector(parent.selector, rule.selector, applyCandidate);\n              rule.walkDecls(d => {\n                d.important = meta.important || important;\n              });\n            });\n          }\n\n          siblings.push([meta, root.nodes[0]]);\n        }\n      } // Inject the rules, sorted, correctly\n\n\n      let nodes = siblings.sort(([a], [z]) => (0, _bigSign.default)(a.sort - z.sort)).map(s => s[1]); // console.log(parent)\n      // `parent` refers to the node at `.abc` in: .abc { @apply mt-2 }\n\n      parent.after(nodes);\n    }\n\n    for (let apply of applies) {\n      // If there are left-over declarations, just remove the @apply\n      if (apply.parent.nodes.length > 1) {\n        apply.remove();\n      } else {\n        // The node is empty, drop the full node\n        apply.parent.remove();\n      }\n    } // Do it again, in case we have other `@apply` rules\n\n\n    processApply(root, context);\n  }\n}\n\nfunction expandApplyAtRules(context) {\n  return root => {\n    partitionApplyParents(root);\n    processApply(root, context);\n  };\n}","map":{"version":3,"sources":["/home/alan/delivery_2/previously_on/client/node_modules/tailwindcss/lib/jit/lib/expandApplyAtRules.js"],"names":["Object","defineProperty","exports","value","default","expandApplyAtRules","_postcss","_interopRequireDefault","require","_generateRules","_bigSign","_escapeClassName","obj","__esModule","buildApplyCache","applyCandidates","context","candidate","notClassCache","has","applyClassCache","classCache","set","get","map","meta","rule","clone","matches","Array","from","resolveMatches","length","add","extractApplyCandidates","params","candidates","split","slice","partitionApplyParents","root","applyParents","Set","walkAtRules","parent","nodeGroups","lastGroup","node","nodes","type","name","push","group","reverse","newParent","append","after","remove","processApply","applies","util","replaceSelector","selector","utilitySelectors","needle","utilitySelectorsList","s","replaced","utilitySelector","replacedSelector","replace","join","perParentApplies","Map","apply","important","screenType","error","c","applyCandidate","rules","siblings","canRewriteSelector","walkRules","walkDecls","d","sort","a","z"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = expandApplyAtRules;\n\nvar _postcss = _interopRequireDefault(require(\"postcss\"));\n\nvar _generateRules = require(\"./generateRules\");\n\nvar _bigSign = _interopRequireDefault(require(\"../../util/bigSign\"));\n\nvar _escapeClassName = _interopRequireDefault(require(\"../../util/escapeClassName\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction buildApplyCache(applyCandidates, context) {\n  for (let candidate of applyCandidates) {\n    if (context.notClassCache.has(candidate) || context.applyClassCache.has(candidate)) {\n      continue;\n    }\n\n    if (context.classCache.has(candidate)) {\n      context.applyClassCache.set(candidate, context.classCache.get(candidate).map(([meta, rule]) => [meta, rule.clone()]));\n      continue;\n    }\n\n    let matches = Array.from((0, _generateRules.resolveMatches)(candidate, context));\n\n    if (matches.length === 0) {\n      context.notClassCache.add(candidate);\n      continue;\n    }\n\n    context.applyClassCache.set(candidate, matches);\n  }\n\n  return context.applyClassCache;\n}\n\nfunction extractApplyCandidates(params) {\n  let candidates = params.split(/[\\s\\t\\n]+/g);\n\n  if (candidates[candidates.length - 1] === '!important') {\n    return [candidates.slice(0, -1), true];\n  }\n\n  return [candidates, false];\n}\n\nfunction partitionApplyParents(root) {\n  let applyParents = new Set();\n  root.walkAtRules('apply', rule => {\n    applyParents.add(rule.parent);\n  });\n\n  for (let rule of applyParents) {\n    let nodeGroups = [];\n    let lastGroup = [];\n\n    for (let node of rule.nodes) {\n      if (node.type === 'atrule' && node.name === 'apply') {\n        if (lastGroup.length > 0) {\n          nodeGroups.push(lastGroup);\n          lastGroup = [];\n        }\n\n        nodeGroups.push([node]);\n      } else {\n        lastGroup.push(node);\n      }\n    }\n\n    if (lastGroup.length > 0) {\n      nodeGroups.push(lastGroup);\n    }\n\n    if (nodeGroups.length === 1) {\n      continue;\n    }\n\n    for (let group of [...nodeGroups].reverse()) {\n      let newParent = rule.clone({\n        nodes: []\n      });\n      newParent.append(group);\n      rule.after(newParent);\n    }\n\n    rule.remove();\n  }\n}\n\nfunction processApply(root, context) {\n  let applyCandidates = new Set(); // Collect all @apply rules and candidates\n\n  let applies = [];\n  root.walkAtRules('apply', rule => {\n    let [candidates] = extractApplyCandidates(rule.params);\n\n    for (let util of candidates) {\n      applyCandidates.add(util);\n    }\n\n    applies.push(rule);\n  }); // Start the @apply process if we have rules with @apply in them\n\n  if (applies.length > 0) {\n    // Fill up some caches!\n    let applyClassCache = buildApplyCache(applyCandidates, context);\n    /**\n     * When we have an apply like this:\n     *\n     * .abc {\n     *    @apply hover:font-bold;\n     * }\n     *\n     * What we essentially will do is resolve to this:\n     *\n     * .abc {\n     *    @apply .hover\\:font-bold:hover {\n     *      font-weight: 500;\n     *    }\n     * }\n     *\n     * Notice that the to-be-applied class is `.hover\\:font-bold:hover` and that the utility candidate was `hover:font-bold`.\n     * What happens in this function is that we prepend a `.` and escape the candidate.\n     * This will result in `.hover\\:font-bold`\n     * Which means that we can replace `.hover\\:font-bold` with `.abc` in `.hover\\:font-bold:hover` resulting in `.abc:hover`\n     */\n    // TODO: Should we use postcss-selector-parser for this instead?\n\n    function replaceSelector(selector, utilitySelectors, candidate) {\n      let needle = `.${(0, _escapeClassName.default)(candidate)}`;\n      let utilitySelectorsList = utilitySelectors.split(/\\s*,\\s*/g);\n      return selector.split(/\\s*,\\s*/g).map(s => {\n        let replaced = [];\n\n        for (let utilitySelector of utilitySelectorsList) {\n          let replacedSelector = utilitySelector.replace(needle, s);\n\n          if (replacedSelector === utilitySelector) {\n            continue;\n          }\n\n          replaced.push(replacedSelector);\n        }\n\n        return replaced.join(', ');\n      }).join(', ');\n    }\n\n    let perParentApplies = new Map(); // Collect all apply candidates and their rules\n\n    for (let apply of applies) {\n      let candidates = perParentApplies.get(apply.parent) || [];\n      perParentApplies.set(apply.parent, candidates);\n      let [applyCandidates, important] = extractApplyCandidates(apply.params);\n\n      if (apply.parent.type === 'atrule') {\n        if (apply.parent.name === 'screen') {\n          const screenType = apply.parent.params;\n          throw apply.error(`@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply ${applyCandidates.map(c => `${screenType}:${c}`).join(' ')} instead.`);\n        }\n\n        throw apply.error(`@apply is not supported within nested at-rules like @${apply.parent.name}. You can fix this by un-nesting @${apply.parent.name}.`);\n      }\n\n      for (let applyCandidate of applyCandidates) {\n        if (!applyClassCache.has(applyCandidate)) {\n          throw apply.error(`The \\`${applyCandidate}\\` class does not exist. If \\`${applyCandidate}\\` is a custom class, make sure it is defined within a \\`@layer\\` directive.`);\n        }\n\n        let rules = applyClassCache.get(applyCandidate);\n        candidates.push([applyCandidate, important, rules]);\n      }\n    }\n\n    for (const [parent, candidates] of perParentApplies) {\n      let siblings = [];\n\n      for (let [applyCandidate, important, rules] of candidates) {\n        for (let [meta, node] of rules) {\n          let root = _postcss.default.root({\n            nodes: [node.clone()]\n          });\n\n          let canRewriteSelector = node.type !== 'atrule' || node.type === 'atrule' && node.name !== 'keyframes';\n\n          if (canRewriteSelector) {\n            root.walkRules(rule => {\n              rule.selector = replaceSelector(parent.selector, rule.selector, applyCandidate);\n              rule.walkDecls(d => {\n                d.important = meta.important || important;\n              });\n            });\n          }\n\n          siblings.push([meta, root.nodes[0]]);\n        }\n      } // Inject the rules, sorted, correctly\n\n\n      let nodes = siblings.sort(([a], [z]) => (0, _bigSign.default)(a.sort - z.sort)).map(s => s[1]); // console.log(parent)\n      // `parent` refers to the node at `.abc` in: .abc { @apply mt-2 }\n\n      parent.after(nodes);\n    }\n\n    for (let apply of applies) {\n      // If there are left-over declarations, just remove the @apply\n      if (apply.parent.nodes.length > 1) {\n        apply.remove();\n      } else {\n        // The node is empty, drop the full node\n        apply.parent.remove();\n      }\n    } // Do it again, in case we have other `@apply` rules\n\n\n    processApply(root, context);\n  }\n}\n\nfunction expandApplyAtRules(context) {\n  return root => {\n    partitionApplyParents(root);\n    processApply(root, context);\n  };\n}"]},"metadata":{},"sourceType":"script"}