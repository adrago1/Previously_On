{"ast":null,"code":"import _toConsumableArray from\"/home/alan/delivery_2/previously_on/client/Previously_On/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import{useMemo}from\"react\";var range=function range(start,end){var length=end-start+1;/* Tableau de taille non définie qui set les \n    elements à l'intérieur de la value de départ à \n    la valeur de fin\n    */return Array.from({length:length},function(_,idx){return idx+start;});};export var usePagination=function usePagination(_ref){var totalCount=_ref.totalCount,pageSize=_ref.pageSize,_ref$siblingCount=_ref.siblingCount,siblingCount=_ref$siblingCount===void 0?1:_ref$siblingCount,currentPage=_ref.currentPage;var paginationRange=useMemo(function(){var totalPageCount=Math.ceil(totalCount/pageSize);var totalPageNumbers=siblingCount+5;/* \n        Cas 1 :  Nombre de page inférieur au nombre \n        de pages qu'on veut afficher dans notre\n        Pagination, on return [1...totalpage]\n        */if(totalPageNumbers>=totalPageCount){return range(1,totalPageCount);}// Met à jour les pages côte a côte \nvar leftSiblingIndex=Math.max(currentPage-siblingCount,1);var rightSiblingIndex=Math.min(currentPage+siblingCount,totalPageCount);// Cacher les points quand il y a seulement une page\nvar shouldShowLeftDots=leftSiblingIndex>2;var shouldShowRightDots=rightSiblingIndex<totalPageCount-2;var firstPageIndex=1;var lastPageIndex=totalPageCount;/*\n        Case 2: Pas de points à droite, mais points à gauche\n        */if(!shouldShowLeftDots&&shouldShowRightDots){var leftItemCount=3+2*siblingCount;var leftRange=range(1,leftItemCount);return[].concat(_toConsumableArray(leftRange),[\"...\",totalPageCount]);}/*\n        Cas 3: Inverse du cas 2\n        */if(shouldShowLeftDots&&!shouldShowRightDots){var rightItemCount=3+2*siblingCount;var rightRange=range(totalPageCount-rightItemCount+1,totalPageCount);return[firstPageIndex,\"...\"].concat(_toConsumableArray(rightRange));}/*\n        Cas 4: Montrer les points des deux côtés\n        */if(shouldShowLeftDots&&shouldShowRightDots){var middleRange=range(leftSiblingIndex,rightSiblingIndex);return[firstPageIndex,\"...\"].concat(_toConsumableArray(middleRange),[\"...\",lastPageIndex]);}},[totalCount,pageSize,siblingCount,currentPage]);return paginationRange;};","map":{"version":3,"sources":["/home/alan/delivery_2/previously_on/client/Previously_On/src/services/usePagination.js"],"names":["useMemo","range","start","end","length","Array","from","_","idx","usePagination","totalCount","pageSize","siblingCount","currentPage","paginationRange","totalPageCount","Math","ceil","totalPageNumbers","leftSiblingIndex","max","rightSiblingIndex","min","shouldShowLeftDots","shouldShowRightDots","firstPageIndex","lastPageIndex","leftItemCount","leftRange","rightItemCount","rightRange","middleRange"],"mappings":"uLAAA,OAASA,OAAT,KAAwB,OAAxB,CAEA,GAAMC,CAAAA,KAAK,CAAG,QAARA,CAAAA,KAAQ,CAACC,KAAD,CAAQC,GAAR,CAAgB,CAC1B,GAAIC,CAAAA,MAAM,CAAGD,GAAG,CAAGD,KAAN,CAAc,CAA3B,CACA;AACJ;AACA;AACA,MAEI,MAAOG,CAAAA,KAAK,CAACC,IAAN,CAAW,CAAEF,MAAM,CAANA,MAAF,CAAX,CAAuB,SAACG,CAAD,CAAIC,GAAJ,QAAYA,CAAAA,GAAG,CAAGN,KAAlB,EAAvB,CAAP,CACH,CARD,CAUA,MAAO,IAAMO,CAAAA,aAAa,CAAG,QAAhBA,CAAAA,aAAgB,MAKvB,IAJFC,CAAAA,UAIE,MAJFA,UAIE,CAHFC,QAGE,MAHFA,QAGE,wBAFFC,YAEE,CAFFA,YAEE,4BAFa,CAEb,mBADFC,WACE,MADFA,WACE,CACF,GAAMC,CAAAA,eAAe,CAAGd,OAAO,CAAC,UAAM,CAClC,GAAMe,CAAAA,cAAc,CAAGC,IAAI,CAACC,IAAL,CAAUP,UAAU,CAAIC,QAAxB,CAAvB,CAEA,GAAMO,CAAAA,gBAAgB,CAAGN,YAAY,CAAG,CAAxC,CAEA;AACR;AACA;AACA;AACA,UACO,GAAIM,gBAAgB,EAAIH,cAAxB,CAAwC,CACpC,MAAOd,CAAAA,KAAK,CAAC,CAAD,CAAIc,cAAJ,CAAZ,CACH,CACD;AACA,GAAMI,CAAAA,gBAAgB,CAAGH,IAAI,CAACI,GAAL,CAASP,WAAW,CAAGD,YAAvB,CAAqC,CAArC,CAAzB,CACA,GAAMS,CAAAA,iBAAiB,CAAGL,IAAI,CAACM,GAAL,CAAST,WAAW,CAAGD,YAAvB,CAAqCG,cAArC,CAA1B,CAEA;AACA,GAAMQ,CAAAA,kBAAkB,CAAGJ,gBAAgB,CAAG,CAA9C,CACA,GAAMK,CAAAA,mBAAmB,CAAGH,iBAAiB,CAAGN,cAAc,CAAG,CAAjE,CAEA,GAAMU,CAAAA,cAAc,CAAG,CAAvB,CACA,GAAMC,CAAAA,aAAa,CAAGX,cAAtB,CAEC;AACR;AACA,UACQ,GAAI,CAACQ,kBAAD,EAAuBC,mBAA3B,CAAgD,CAC5C,GAAIG,CAAAA,aAAa,CAAG,EAAI,EAAIf,YAA5B,CACA,GAAIgB,CAAAA,SAAS,CAAG3B,KAAK,CAAC,CAAD,CAAI0B,aAAJ,CAArB,CAEA,mCAAWC,SAAX,GAAsB,KAAtB,CAA6Bb,cAA7B,GACH,CAED;AACR;AACA,UACQ,GAAIQ,kBAAkB,EAAI,CAACC,mBAA3B,CAAgD,CAC5C,GAAIK,CAAAA,cAAc,CAAG,EAAI,EAAIjB,YAA7B,CACA,GAAIkB,CAAAA,UAAU,CAAG7B,KAAK,CAClBc,cAAc,CAAGc,cAAjB,CAAkC,CADhB,CACmBd,cADnB,CAAtB,CAGA,OAAQU,cAAR,CAAwB,KAAxB,4BAAkCK,UAAlC,GACH,CAED;AACR;AACA,UACO,GAAIP,kBAAkB,EAAIC,mBAA1B,CAA+C,CAC3C,GAAIO,CAAAA,WAAW,CAAG9B,KAAK,CAACkB,gBAAD,CAAmBE,iBAAnB,CAAvB,CACA,OAAQI,cAAR,CAAwB,KAAxB,4BAAkCM,WAAlC,GAA+C,KAA/C,CAAsDL,aAAtD,GACH,CAEH,CArD8B,CAqD5B,CAAChB,UAAD,CAAaC,QAAb,CAAuBC,YAAvB,CAAqCC,WAArC,CArD4B,CAA/B,CAuDA,MAAOC,CAAAA,eAAP,CACH,CA9DM","sourcesContent":["import { useMemo } from \"react\";\n\nconst range = (start, end) => {\n    let length = end - start + 1;\n    /* Tableau de taille non définie qui set les \n    elements à l'intérieur de la value de départ à \n    la valeur de fin\n    */\n\n    return Array.from({ length }, (_, idx) => idx + start);\n}\n\nexport const usePagination = ({\n    totalCount,\n    pageSize,\n    siblingCount = 1,\n    currentPage\n}) => {\n    const paginationRange = useMemo(() => {\n        const totalPageCount = Math.ceil(totalCount /  pageSize);\n\n        const totalPageNumbers = siblingCount + 5;\n\n        /* \n        Cas 1 :  Nombre de page inférieur au nombre \n        de pages qu'on veut afficher dans notre\n        Pagination, on return [1...totalpage]\n        */\n       if (totalPageNumbers >= totalPageCount) {\n           return range(1, totalPageCount);\n       }\n       // Met à jour les pages côte a côte \n       const leftSiblingIndex = Math.max(currentPage - siblingCount, 1);\n       const rightSiblingIndex = Math.min(currentPage + siblingCount, totalPageCount);\n\n       // Cacher les points quand il y a seulement une page\n       const shouldShowLeftDots = leftSiblingIndex > 2;\n       const shouldShowRightDots = rightSiblingIndex < totalPageCount - 2;\n\n       const firstPageIndex = 1;\n       const lastPageIndex = totalPageCount;\n\n        /*\n        Case 2: Pas de points à droite, mais points à gauche\n        */\n        if (!shouldShowLeftDots && shouldShowRightDots) {\n            let leftItemCount = 3 + 2 * siblingCount;\n            let leftRange = range(1, leftItemCount);\n\n            return [...leftRange, \"...\", totalPageCount];\n        }\n\n        /*\n        Cas 3: Inverse du cas 2\n        */\n        if (shouldShowLeftDots && !shouldShowRightDots) {\n            let rightItemCount = 3 + 2 * siblingCount;\n            let rightRange = range(\n                totalPageCount - rightItemCount + 1, totalPageCount\n            );\n            return [firstPageIndex, \"...\", ...rightRange];\n        }\n\n        /*\n        Cas 4: Montrer les points des deux côtés\n        */\n       if (shouldShowLeftDots && shouldShowRightDots) {\n           let middleRange = range(leftSiblingIndex, rightSiblingIndex);\n           return [firstPageIndex, \"...\", ...middleRange, \"...\", lastPageIndex];\n       }\n\n    }, [totalCount, pageSize, siblingCount, currentPage]);\n\n    return paginationRange;\n}"]},"metadata":{},"sourceType":"module"}