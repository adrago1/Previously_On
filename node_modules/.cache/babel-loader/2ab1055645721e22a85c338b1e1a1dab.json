{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.applyPseudoToMarker = applyPseudoToMarker;\nexports.updateAllClasses = updateAllClasses;\nexports.updateLastClasses = updateLastClasses;\nexports.transformAllSelectors = transformAllSelectors;\nexports.transformAllClasses = transformAllClasses;\nexports.transformLastClasses = transformLastClasses;\nexports.asValue = asValue;\nexports.asUnit = asUnit;\nexports.asList = asList;\nexports.asColor = asColor;\nexports.asAngle = asAngle;\nexports.asLength = asLength;\nexports.asLookupValue = asLookupValue;\nexports.coerceValue = coerceValue;\n\nvar _postcssSelectorParser = _interopRequireDefault(require(\"postcss-selector-parser\"));\n\nvar _postcss = _interopRequireDefault(require(\"postcss\"));\n\nvar _color = _interopRequireDefault(require(\"color\"));\n\nvar _escapeCommas = _interopRequireDefault(require(\"./escapeCommas\"));\n\nvar _withAlphaVariable = require(\"./withAlphaVariable\");\n\nvar _isKeyframeRule = _interopRequireDefault(require(\"./isKeyframeRule\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction applyPseudoToMarker(selector, marker, state, join) {\n  let states = [state];\n  let markerIdx = selector.indexOf(marker + ':');\n\n  if (markerIdx !== -1) {\n    let existingMarker = selector.slice(markerIdx, selector.indexOf(' ', markerIdx));\n    states = states.concat(selector.slice(markerIdx + marker.length + 1, existingMarker.length).split(':'));\n    selector = selector.replace(existingMarker, '');\n  }\n\n  return join(`${[marker, ...states].join(':')}`, selector);\n}\n\nfunction updateAllClasses(selectors, updateClass) {\n  let parser = (0, _postcssSelectorParser.default)(selectors => {\n    selectors.walkClasses(sel => {\n      let updatedClass = updateClass(sel.value, {\n        withPseudo(className, pseudo) {\n          sel.parent.insertAfter(sel, _postcssSelectorParser.default.pseudo({\n            value: `${pseudo}`\n          }));\n          return className;\n        }\n\n      });\n      sel.value = updatedClass;\n\n      if (sel.raws && sel.raws.value) {\n        sel.raws.value = (0, _escapeCommas.default)(sel.raws.value);\n      }\n    });\n  });\n  let result = parser.processSync(selectors);\n  return result;\n}\n\nfunction updateLastClasses(selectors, updateClass) {\n  let parser = (0, _postcssSelectorParser.default)(selectors => {\n    selectors.each(sel => {\n      let lastClass = sel.filter(({\n        type\n      }) => type === 'class').pop();\n\n      if (lastClass === undefined) {\n        return;\n      }\n\n      let updatedClass = updateClass(lastClass.value, {\n        withPseudo(className, pseudo) {\n          lastClass.parent.insertAfter(lastClass, _postcssSelectorParser.default.pseudo({\n            value: `${pseudo}`\n          }));\n          return className;\n        }\n\n      });\n      lastClass.value = updatedClass;\n\n      if (lastClass.raws && lastClass.raws.value) {\n        lastClass.raws.value = (0, _escapeCommas.default)(lastClass.raws.value);\n      }\n    });\n  });\n  let result = parser.processSync(selectors);\n  return result;\n}\n\nfunction splitByNotEscapedCommas(str) {\n  let chunks = [];\n  let currentChunk = '';\n\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === ',' && str[i - 1] !== '\\\\') {\n      chunks.push(currentChunk);\n      currentChunk = '';\n    } else {\n      currentChunk += str[i];\n    }\n  }\n\n  chunks.push(currentChunk);\n  return chunks;\n}\n\nfunction transformAllSelectors(transformSelector, {\n  wrap,\n  withRule\n} = {}) {\n  return ({\n    container\n  }) => {\n    container.walkRules(rule => {\n      if ((0, _isKeyframeRule.default)(rule)) {\n        return rule;\n      }\n\n      let transformed = splitByNotEscapedCommas(rule.selector).map(transformSelector).join(',');\n      rule.selector = transformed;\n\n      if (withRule) {\n        withRule(rule);\n      }\n\n      return rule;\n    });\n\n    if (wrap) {\n      let wrapper = wrap();\n      let nodes = container.nodes;\n      container.removeAll();\n      wrapper.append(nodes);\n      container.append(wrapper);\n    }\n  };\n}\n\nfunction transformAllClasses(transformClass, {\n  wrap,\n  withRule\n} = {}) {\n  return ({\n    container\n  }) => {\n    container.walkRules(rule => {\n      let selector = rule.selector;\n      let variantSelector = updateAllClasses(selector, transformClass);\n      rule.selector = variantSelector;\n\n      if (withRule) {\n        withRule(rule);\n      }\n\n      return rule;\n    });\n\n    if (wrap) {\n      let wrapper = wrap();\n      let nodes = container.nodes;\n      container.removeAll();\n      wrapper.append(nodes);\n      container.append(wrapper);\n    }\n  };\n}\n\nfunction transformLastClasses(transformClass, {\n  wrap,\n  withRule\n} = {}) {\n  return ({\n    container\n  }) => {\n    container.walkRules(rule => {\n      let selector = rule.selector;\n      let variantSelector = updateLastClasses(selector, transformClass);\n      rule.selector = variantSelector;\n\n      if (withRule) {\n        withRule(rule);\n      }\n\n      return rule;\n    });\n\n    if (wrap) {\n      let wrapper = wrap();\n      let nodes = container.nodes;\n      container.removeAll();\n      wrapper.append(nodes);\n      container.append(wrapper);\n    }\n  };\n}\n\nfunction asValue(modifier, lookup = {}, {\n  validate = () => true,\n  transform = v => v\n} = {}) {\n  let value = lookup[modifier];\n\n  if (value !== undefined) {\n    return value;\n  }\n\n  if (modifier[0] !== '[' || modifier[modifier.length - 1] !== ']') {\n    return undefined;\n  }\n\n  value = modifier.slice(1, -1);\n\n  if (!validate(value)) {\n    return undefined;\n  } // add spaces around operators inside calc() that do not follow an operator or (\n\n\n  return transform(value).replace(/(-?\\d*\\.?\\d(?!\\b-.+[,)](?![^+\\-/*])\\D)(?:%|[a-z]+)?|\\))([+\\-/*])/g, '$1 $2 ');\n}\n\nfunction asUnit(modifier, units, lookup = {}) {\n  return asValue(modifier, lookup, {\n    validate: value => {\n      let unitsPattern = `(?:${units.join('|')})`;\n      return new RegExp(`${unitsPattern}$`).test(value) || new RegExp(`^calc\\\\(.+?${unitsPattern}`).test(value);\n    },\n    transform: value => {\n      return value;\n    }\n  });\n}\n\nfunction asList(modifier, lookup = {}) {\n  return asValue(modifier, lookup, {\n    transform: value => {\n      return _postcss.default.list.comma(value).map(v => v.replace(/,/g, ', ')).join(' ');\n    }\n  });\n}\n\nfunction isArbitraryValue(input) {\n  return input.startsWith('[') && input.endsWith(']');\n}\n\nfunction splitAlpha(modifier) {\n  let slashIdx = modifier.lastIndexOf('/');\n\n  if (slashIdx === -1 || slashIdx === modifier.length - 1) {\n    return [modifier];\n  }\n\n  return [modifier.slice(0, slashIdx), modifier.slice(slashIdx + 1)];\n}\n\nfunction isColor(value) {\n  try {\n    (0, _color.default)(value);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction asColor(modifier, lookup = {}, tailwindConfig = {}) {\n  if (lookup[modifier] !== undefined) {\n    return lookup[modifier];\n  }\n\n  let [color, alpha] = splitAlpha(modifier);\n\n  if (lookup[color] !== undefined) {\n    var _tailwindConfig$theme, _tailwindConfig$theme2;\n\n    if (isArbitraryValue(alpha)) {\n      return (0, _withAlphaVariable.withAlphaValue)(lookup[color], alpha.slice(1, -1));\n    }\n\n    if (((_tailwindConfig$theme = tailwindConfig.theme) === null || _tailwindConfig$theme === void 0 ? void 0 : (_tailwindConfig$theme2 = _tailwindConfig$theme.opacity) === null || _tailwindConfig$theme2 === void 0 ? void 0 : _tailwindConfig$theme2[alpha]) === undefined) {\n      return undefined;\n    }\n\n    return (0, _withAlphaVariable.withAlphaValue)(lookup[color], tailwindConfig.theme.opacity[alpha]);\n  }\n\n  return asValue(modifier, lookup, {\n    validate: isColor\n  });\n}\n\nfunction asAngle(modifier, lookup = {}) {\n  return asUnit(modifier, ['deg', 'grad', 'rad', 'turn'], lookup);\n}\n\nfunction asLength(modifier, lookup = {}) {\n  return asUnit(modifier, ['cm', 'mm', 'Q', 'in', 'pc', 'pt', 'px', 'em', 'ex', 'ch', 'rem', 'lh', 'vw', 'vh', 'vmin', 'vmax', '%'], lookup);\n}\n\nfunction asLookupValue(modifier, lookup = {}) {\n  return lookup[modifier];\n}\n\nlet typeMap = {\n  any: asValue,\n  list: asList,\n  color: asColor,\n  angle: asAngle,\n  length: asLength,\n  lookup: asLookupValue\n};\n\nfunction splitAtFirst(input, delim) {\n  return (([first, ...rest]) => [first, rest.join(delim)])(input.split(delim));\n}\n\nfunction coerceValue(type, modifier, values, tailwindConfig) {\n  let [scaleType, arbitraryType = scaleType] = [].concat(type);\n\n  if (isArbitraryValue(modifier)) {\n    let [explicitType, value] = splitAtFirst(modifier.slice(1, -1), ':');\n\n    if (value.length > 0 && Object.keys(typeMap).includes(explicitType)) {\n      return [asValue(`[${value}]`, values, tailwindConfig), explicitType];\n    }\n\n    return [typeMap[arbitraryType](modifier, values, tailwindConfig), arbitraryType];\n  }\n\n  return [typeMap[scaleType](modifier, values, tailwindConfig), scaleType];\n}","map":{"version":3,"sources":["/home/alan/delivery_2/previously_on/client/node_modules/tailwindcss/lib/util/pluginUtils.js"],"names":["Object","defineProperty","exports","value","applyPseudoToMarker","updateAllClasses","updateLastClasses","transformAllSelectors","transformAllClasses","transformLastClasses","asValue","asUnit","asList","asColor","asAngle","asLength","asLookupValue","coerceValue","_postcssSelectorParser","_interopRequireDefault","require","_postcss","_color","_escapeCommas","_withAlphaVariable","_isKeyframeRule","obj","__esModule","default","selector","marker","state","join","states","markerIdx","indexOf","existingMarker","slice","concat","length","split","replace","selectors","updateClass","parser","walkClasses","sel","updatedClass","withPseudo","className","pseudo","parent","insertAfter","raws","result","processSync","each","lastClass","filter","type","pop","undefined","splitByNotEscapedCommas","str","chunks","currentChunk","i","push","transformSelector","wrap","withRule","container","walkRules","rule","transformed","map","wrapper","nodes","removeAll","append","transformClass","variantSelector","modifier","lookup","validate","transform","v","units","unitsPattern","RegExp","test","list","comma","isArbitraryValue","input","startsWith","endsWith","splitAlpha","slashIdx","lastIndexOf","isColor","e","tailwindConfig","color","alpha","_tailwindConfig$theme","_tailwindConfig$theme2","withAlphaValue","theme","opacity","typeMap","any","angle","splitAtFirst","delim","first","rest","values","scaleType","arbitraryType","explicitType","keys","includes"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.applyPseudoToMarker = applyPseudoToMarker;\nexports.updateAllClasses = updateAllClasses;\nexports.updateLastClasses = updateLastClasses;\nexports.transformAllSelectors = transformAllSelectors;\nexports.transformAllClasses = transformAllClasses;\nexports.transformLastClasses = transformLastClasses;\nexports.asValue = asValue;\nexports.asUnit = asUnit;\nexports.asList = asList;\nexports.asColor = asColor;\nexports.asAngle = asAngle;\nexports.asLength = asLength;\nexports.asLookupValue = asLookupValue;\nexports.coerceValue = coerceValue;\n\nvar _postcssSelectorParser = _interopRequireDefault(require(\"postcss-selector-parser\"));\n\nvar _postcss = _interopRequireDefault(require(\"postcss\"));\n\nvar _color = _interopRequireDefault(require(\"color\"));\n\nvar _escapeCommas = _interopRequireDefault(require(\"./escapeCommas\"));\n\nvar _withAlphaVariable = require(\"./withAlphaVariable\");\n\nvar _isKeyframeRule = _interopRequireDefault(require(\"./isKeyframeRule\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction applyPseudoToMarker(selector, marker, state, join) {\n  let states = [state];\n  let markerIdx = selector.indexOf(marker + ':');\n\n  if (markerIdx !== -1) {\n    let existingMarker = selector.slice(markerIdx, selector.indexOf(' ', markerIdx));\n    states = states.concat(selector.slice(markerIdx + marker.length + 1, existingMarker.length).split(':'));\n    selector = selector.replace(existingMarker, '');\n  }\n\n  return join(`${[marker, ...states].join(':')}`, selector);\n}\n\nfunction updateAllClasses(selectors, updateClass) {\n  let parser = (0, _postcssSelectorParser.default)(selectors => {\n    selectors.walkClasses(sel => {\n      let updatedClass = updateClass(sel.value, {\n        withPseudo(className, pseudo) {\n          sel.parent.insertAfter(sel, _postcssSelectorParser.default.pseudo({\n            value: `${pseudo}`\n          }));\n          return className;\n        }\n\n      });\n      sel.value = updatedClass;\n\n      if (sel.raws && sel.raws.value) {\n        sel.raws.value = (0, _escapeCommas.default)(sel.raws.value);\n      }\n    });\n  });\n  let result = parser.processSync(selectors);\n  return result;\n}\n\nfunction updateLastClasses(selectors, updateClass) {\n  let parser = (0, _postcssSelectorParser.default)(selectors => {\n    selectors.each(sel => {\n      let lastClass = sel.filter(({\n        type\n      }) => type === 'class').pop();\n\n      if (lastClass === undefined) {\n        return;\n      }\n\n      let updatedClass = updateClass(lastClass.value, {\n        withPseudo(className, pseudo) {\n          lastClass.parent.insertAfter(lastClass, _postcssSelectorParser.default.pseudo({\n            value: `${pseudo}`\n          }));\n          return className;\n        }\n\n      });\n      lastClass.value = updatedClass;\n\n      if (lastClass.raws && lastClass.raws.value) {\n        lastClass.raws.value = (0, _escapeCommas.default)(lastClass.raws.value);\n      }\n    });\n  });\n  let result = parser.processSync(selectors);\n  return result;\n}\n\nfunction splitByNotEscapedCommas(str) {\n  let chunks = [];\n  let currentChunk = '';\n\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === ',' && str[i - 1] !== '\\\\') {\n      chunks.push(currentChunk);\n      currentChunk = '';\n    } else {\n      currentChunk += str[i];\n    }\n  }\n\n  chunks.push(currentChunk);\n  return chunks;\n}\n\nfunction transformAllSelectors(transformSelector, {\n  wrap,\n  withRule\n} = {}) {\n  return ({\n    container\n  }) => {\n    container.walkRules(rule => {\n      if ((0, _isKeyframeRule.default)(rule)) {\n        return rule;\n      }\n\n      let transformed = splitByNotEscapedCommas(rule.selector).map(transformSelector).join(',');\n      rule.selector = transformed;\n\n      if (withRule) {\n        withRule(rule);\n      }\n\n      return rule;\n    });\n\n    if (wrap) {\n      let wrapper = wrap();\n      let nodes = container.nodes;\n      container.removeAll();\n      wrapper.append(nodes);\n      container.append(wrapper);\n    }\n  };\n}\n\nfunction transformAllClasses(transformClass, {\n  wrap,\n  withRule\n} = {}) {\n  return ({\n    container\n  }) => {\n    container.walkRules(rule => {\n      let selector = rule.selector;\n      let variantSelector = updateAllClasses(selector, transformClass);\n      rule.selector = variantSelector;\n\n      if (withRule) {\n        withRule(rule);\n      }\n\n      return rule;\n    });\n\n    if (wrap) {\n      let wrapper = wrap();\n      let nodes = container.nodes;\n      container.removeAll();\n      wrapper.append(nodes);\n      container.append(wrapper);\n    }\n  };\n}\n\nfunction transformLastClasses(transformClass, {\n  wrap,\n  withRule\n} = {}) {\n  return ({\n    container\n  }) => {\n    container.walkRules(rule => {\n      let selector = rule.selector;\n      let variantSelector = updateLastClasses(selector, transformClass);\n      rule.selector = variantSelector;\n\n      if (withRule) {\n        withRule(rule);\n      }\n\n      return rule;\n    });\n\n    if (wrap) {\n      let wrapper = wrap();\n      let nodes = container.nodes;\n      container.removeAll();\n      wrapper.append(nodes);\n      container.append(wrapper);\n    }\n  };\n}\n\nfunction asValue(modifier, lookup = {}, {\n  validate = () => true,\n  transform = v => v\n} = {}) {\n  let value = lookup[modifier];\n\n  if (value !== undefined) {\n    return value;\n  }\n\n  if (modifier[0] !== '[' || modifier[modifier.length - 1] !== ']') {\n    return undefined;\n  }\n\n  value = modifier.slice(1, -1);\n\n  if (!validate(value)) {\n    return undefined;\n  } // add spaces around operators inside calc() that do not follow an operator or (\n\n\n  return transform(value).replace(/(-?\\d*\\.?\\d(?!\\b-.+[,)](?![^+\\-/*])\\D)(?:%|[a-z]+)?|\\))([+\\-/*])/g, '$1 $2 ');\n}\n\nfunction asUnit(modifier, units, lookup = {}) {\n  return asValue(modifier, lookup, {\n    validate: value => {\n      let unitsPattern = `(?:${units.join('|')})`;\n      return new RegExp(`${unitsPattern}$`).test(value) || new RegExp(`^calc\\\\(.+?${unitsPattern}`).test(value);\n    },\n    transform: value => {\n      return value;\n    }\n  });\n}\n\nfunction asList(modifier, lookup = {}) {\n  return asValue(modifier, lookup, {\n    transform: value => {\n      return _postcss.default.list.comma(value).map(v => v.replace(/,/g, ', ')).join(' ');\n    }\n  });\n}\n\nfunction isArbitraryValue(input) {\n  return input.startsWith('[') && input.endsWith(']');\n}\n\nfunction splitAlpha(modifier) {\n  let slashIdx = modifier.lastIndexOf('/');\n\n  if (slashIdx === -1 || slashIdx === modifier.length - 1) {\n    return [modifier];\n  }\n\n  return [modifier.slice(0, slashIdx), modifier.slice(slashIdx + 1)];\n}\n\nfunction isColor(value) {\n  try {\n    (0, _color.default)(value);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction asColor(modifier, lookup = {}, tailwindConfig = {}) {\n  if (lookup[modifier] !== undefined) {\n    return lookup[modifier];\n  }\n\n  let [color, alpha] = splitAlpha(modifier);\n\n  if (lookup[color] !== undefined) {\n    var _tailwindConfig$theme, _tailwindConfig$theme2;\n\n    if (isArbitraryValue(alpha)) {\n      return (0, _withAlphaVariable.withAlphaValue)(lookup[color], alpha.slice(1, -1));\n    }\n\n    if (((_tailwindConfig$theme = tailwindConfig.theme) === null || _tailwindConfig$theme === void 0 ? void 0 : (_tailwindConfig$theme2 = _tailwindConfig$theme.opacity) === null || _tailwindConfig$theme2 === void 0 ? void 0 : _tailwindConfig$theme2[alpha]) === undefined) {\n      return undefined;\n    }\n\n    return (0, _withAlphaVariable.withAlphaValue)(lookup[color], tailwindConfig.theme.opacity[alpha]);\n  }\n\n  return asValue(modifier, lookup, {\n    validate: isColor\n  });\n}\n\nfunction asAngle(modifier, lookup = {}) {\n  return asUnit(modifier, ['deg', 'grad', 'rad', 'turn'], lookup);\n}\n\nfunction asLength(modifier, lookup = {}) {\n  return asUnit(modifier, ['cm', 'mm', 'Q', 'in', 'pc', 'pt', 'px', 'em', 'ex', 'ch', 'rem', 'lh', 'vw', 'vh', 'vmin', 'vmax', '%'], lookup);\n}\n\nfunction asLookupValue(modifier, lookup = {}) {\n  return lookup[modifier];\n}\n\nlet typeMap = {\n  any: asValue,\n  list: asList,\n  color: asColor,\n  angle: asAngle,\n  length: asLength,\n  lookup: asLookupValue\n};\n\nfunction splitAtFirst(input, delim) {\n  return (([first, ...rest]) => [first, rest.join(delim)])(input.split(delim));\n}\n\nfunction coerceValue(type, modifier, values, tailwindConfig) {\n  let [scaleType, arbitraryType = scaleType] = [].concat(type);\n\n  if (isArbitraryValue(modifier)) {\n    let [explicitType, value] = splitAtFirst(modifier.slice(1, -1), ':');\n\n    if (value.length > 0 && Object.keys(typeMap).includes(explicitType)) {\n      return [asValue(`[${value}]`, values, tailwindConfig), explicitType];\n    }\n\n    return [typeMap[arbitraryType](modifier, values, tailwindConfig), arbitraryType];\n  }\n\n  return [typeMap[scaleType](modifier, values, tailwindConfig), scaleType];\n}"]},"metadata":{},"sourceType":"script"}