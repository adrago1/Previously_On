{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = substituteClassApplyAtRules;\n\nvar _lodash = _interopRequireDefault(require(\"lodash\"));\n\nvar _postcssSelectorParser = _interopRequireDefault(require(\"postcss-selector-parser\"));\n\nvar _postcss = _interopRequireDefault(require(\"postcss\"));\n\nvar _didyoumean = _interopRequireDefault(require(\"didyoumean\"));\n\nvar _substituteTailwindAtRules = _interopRequireDefault(require(\"./substituteTailwindAtRules\"));\n\nvar _evaluateTailwindFunctions = _interopRequireDefault(require(\"./evaluateTailwindFunctions\"));\n\nvar _substituteVariantsAtRules = _interopRequireDefault(require(\"./substituteVariantsAtRules\"));\n\nvar _substituteResponsiveAtRules = _interopRequireDefault(require(\"./substituteResponsiveAtRules\"));\n\nvar _convertLayerAtRulesToControlComments = _interopRequireDefault(require(\"./convertLayerAtRulesToControlComments\"));\n\nvar _substituteScreenAtRules = _interopRequireDefault(require(\"./substituteScreenAtRules\"));\n\nvar _prefixSelector = _interopRequireDefault(require(\"../util/prefixSelector\"));\n\nvar _useMemo = require(\"../util/useMemo\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction hasAtRule(css, atRule, condition) {\n  let found = false;\n  css.walkAtRules(atRule, condition === undefined ? () => {\n    found = true;\n    return false;\n  } : node => {\n    if (condition(node)) {\n      found = true;\n      return false;\n    }\n  });\n  return found;\n}\n\nfunction cloneWithoutChildren(node) {\n  if (node.type === 'atrule') {\n    return _postcss.default.atRule({\n      name: node.name,\n      params: node.params\n    });\n  }\n\n  if (node.type === 'rule') {\n    return _postcss.default.rule({\n      name: node.name,\n      selectors: node.selectors\n    });\n  }\n\n  const clone = node.clone();\n  clone.removeAll();\n  return clone;\n}\n\nconst tailwindApplyPlaceholder = _postcssSelectorParser.default.attribute({\n  attribute: '__TAILWIND-APPLY-PLACEHOLDER__'\n});\n\nfunction generateRulesFromApply({\n  rule,\n  utilityName: className,\n  classPosition\n}, replaceWiths) {\n  const parser = (0, _postcssSelectorParser.default)(selectors => {\n    let i = 0;\n    selectors.walkClasses(c => {\n      if (classPosition === i++ && c.value === className) {\n        c.replaceWith(tailwindApplyPlaceholder);\n      }\n    });\n  });\n\n  const processedSelectors = _lodash.default.flatMap(rule.selectors, selector => {\n    // You could argue we should make this replacement at the AST level, but if we believe\n    // the placeholder string is safe from collisions then it is safe to do this is a simple\n    // string replacement, and much, much faster.\n    return replaceWiths.map(replaceWith => parser.processSync(selector).replace('[__TAILWIND-APPLY-PLACEHOLDER__]', replaceWith));\n  });\n\n  const cloned = rule.clone();\n  let current = cloned;\n  let parent = rule.parent;\n\n  while (parent && parent.type !== 'root') {\n    const parentClone = cloneWithoutChildren(parent);\n    parentClone.append(current);\n    current.parent = parentClone;\n    current = parentClone;\n    parent = parent.parent;\n  }\n\n  cloned.selectors = processedSelectors;\n  return current;\n}\n\nconst extractUtilityNamesParser = (0, _postcssSelectorParser.default)(selectors => {\n  let classes = [];\n  selectors.walkClasses(c => classes.push(c.value));\n  return classes;\n});\nconst extractUtilityNames = (0, _useMemo.useMemo)(selector => extractUtilityNamesParser.transformSync(selector), selector => selector);\nconst cloneRuleWithParent = (0, _useMemo.useMemo)(rule => rule.clone({\n  parent: rule.parent\n}), rule => rule);\n\nfunction buildCssUtilityMap(css, startIndex) {\n  let index = startIndex;\n  const utilityMap = {};\n\n  function handle(getRule, rule) {\n    const utilityNames = extractUtilityNames(rule.selector);\n    utilityNames.forEach((utilityName, i) => {\n      if (utilityMap[utilityName] === undefined) {\n        utilityMap[utilityName] = [];\n      }\n\n      utilityMap[utilityName].push({\n        index,\n        utilityName,\n        classPosition: i,\n        ...getRule(rule)\n      });\n      index++;\n    });\n  } // This is the end user's css. This might contain rules that we want to\n  // apply. We want immediate copies of everything in case that we have user\n  // defined classes that are recursively applied. Down below we are modifying\n  // the rules directly. We could do a better solution where we keep track of a\n  // dependency tree, but that is a bit more complex. Might revisit later,\n  // we'll see how this turns out!\n\n\n  css.walkRules(handle.bind(null, rule => ({\n    rule: cloneRuleWithParent(rule)\n  })));\n  return utilityMap;\n}\n\nconst buildLookupTreeUtilityMap = (0, _useMemo.useMemo)(lookupTree => {\n  let index = 0;\n  const utilityMap = {};\n\n  function handle(getRule, rule) {\n    const utilityNames = extractUtilityNames(rule.selector);\n    utilityNames.forEach((utilityName, i) => {\n      if (utilityMap[utilityName] === undefined) {\n        utilityMap[utilityName] = [];\n      }\n\n      utilityMap[utilityName].push({\n        index,\n        utilityName,\n        classPosition: i,\n        ...getRule(rule)\n      });\n      index++;\n    });\n  } // Lookup tree is the big lookup tree, making the rule lazy allows us to save\n  // some memory because we don't need everything.\n\n\n  lookupTree.walkRules(handle.bind(null, rule => ({\n    get rule() {\n      return cloneRuleWithParent(rule);\n    }\n\n  })));\n  return utilityMap;\n}, tree => tree);\n\nfunction mergeAdjacentRules(initialRule, rulesToInsert) {\n  let previousRule = initialRule;\n  rulesToInsert.forEach(toInsert => {\n    if (toInsert.type === 'rule' && previousRule.type === 'rule' && toInsert.selector === previousRule.selector) {\n      previousRule.append(toInsert.nodes);\n    } else if (toInsert.type === 'atrule' && previousRule.type === 'atrule' && toInsert.params === previousRule.params) {\n      const merged = mergeAdjacentRules(previousRule.nodes[previousRule.nodes.length - 1], toInsert.nodes);\n      previousRule.append(merged);\n    } else {\n      previousRule = toInsert;\n    }\n\n    toInsert.walk(n => {\n      if (n.nodes && n.nodes.length === 0) {\n        n.remove();\n      }\n    });\n  });\n  return rulesToInsert.filter(r => r.nodes.length > 0);\n}\n\nfunction makeExtractUtilityRules(css, lookupTree, config) {\n  const lookupTreeUtilityMap = buildLookupTreeUtilityMap(lookupTree);\n  const lookupTreeUtilityMapKeys = Object.keys(lookupTreeUtilityMap);\n  const utilityMap = buildCssUtilityMap(css, lookupTreeUtilityMapKeys.length);\n\n  function getUtility(utilityName) {\n    const utility = [];\n\n    if (lookupTreeUtilityMap[utilityName]) {\n      utility.push(...lookupTreeUtilityMap[utilityName]);\n    }\n\n    if (utilityMap[utilityName]) {\n      utility.push(...utilityMap[utilityName]);\n    }\n\n    if (utility.length > 0) return utility;\n  }\n\n  return function extractUtilityRules(utilityNames, rule) {\n    const combined = [];\n    utilityNames.forEach(utilityName => {\n      const utility = getUtility(utilityName);\n\n      if (utility === undefined) {\n        // Look for prefixed utility in case the user has goofed\n        const prefixedUtilityName = (0, _prefixSelector.default)(config.prefix, `.${utilityName}`).slice(1);\n        const prefixedUtility = getUtility(prefixedUtilityName);\n\n        if (prefixedUtility !== undefined) {\n          throw rule.error(`The \\`${utilityName}\\` class does not exist, but \\`${prefixedUtilityName}\\` does. Did you forget the prefix?`);\n        }\n\n        const suggestedClass = (0, _didyoumean.default)(utilityName, Object.keys(utilityMap).concat(lookupTreeUtilityMapKeys));\n        const suggestionMessage = suggestedClass ? `, but \\`${suggestedClass}\\` does` : '';\n        throw rule.error(`The \\`${utilityName}\\` class does not exist${suggestionMessage}. If you're sure that \\`${utilityName}\\` exists, make sure that any \\`@import\\` statements are being properly processed before Tailwind CSS sees your CSS, as \\`@apply\\` can only be used for classes in the same CSS tree.`, {\n          word: utilityName\n        });\n      }\n\n      combined.push(...utility);\n    });\n    return combined.sort((a, b) => a.index - b.index);\n  };\n}\n\nfunction findParent(rule, predicate) {\n  let parent = rule.parent;\n\n  while (parent) {\n    if (predicate(parent)) {\n      return parent;\n    }\n\n    parent = parent.parent;\n  }\n\n  throw new Error('No parent could be found');\n}\n\nfunction processApplyAtRules(css, lookupTree, config) {\n  const extractUtilityRules = makeExtractUtilityRules(css, lookupTree, config);\n\n  do {\n    css.walkAtRules('apply', applyRule => {\n      const parent = applyRule.parent; // Direct parent\n\n      const nearestParentRule = findParent(applyRule, r => r.type === 'rule');\n      const currentUtilityNames = extractUtilityNames(nearestParentRule.selector);\n\n      const [importantEntries, applyUtilityNames, important = importantEntries.length > 0] = _lodash.default.partition(applyRule.params.split(/[\\s\\t\\n]+/g), n => n === '!important');\n\n      if (_lodash.default.intersection(applyUtilityNames, currentUtilityNames).length > 0) {\n        const currentUtilityName = _lodash.default.intersection(applyUtilityNames, currentUtilityNames)[0];\n\n        throw parent.error(`You cannot \\`@apply\\` the \\`${currentUtilityName}\\` utility here because it creates a circular dependency.`);\n      } // Extract any post-apply declarations and re-insert them after apply rules\n\n\n      const afterRule = parent.clone({\n        raws: {}\n      });\n      afterRule.nodes = afterRule.nodes.slice(parent.index(applyRule) + 1);\n      parent.nodes = parent.nodes.slice(0, parent.index(applyRule) + 1); // Sort applys to match CSS source order\n\n      const applys = extractUtilityRules(applyUtilityNames, applyRule); // Get new rules with the utility portion of the selector replaced with the new selector\n\n      const rulesToInsert = [];\n      applys.forEach(nearestParentRule === parent ? util => rulesToInsert.push(generateRulesFromApply(util, parent.selectors)) : util => util.rule.nodes.forEach(n => afterRule.append(n.clone())));\n      rulesToInsert.forEach(rule => {\n        if (rule.type === 'atrule') {\n          rule.walkRules(rule => {\n            rule.__tailwind = { ...rule.__tailwind,\n              important\n            };\n          });\n        } else {\n          rule.__tailwind = { ...rule.__tailwind,\n            important\n          };\n        }\n      });\n\n      const {\n        nodes\n      } = _lodash.default.tap(_postcss.default.root({\n        nodes: rulesToInsert\n      }), root => {\n        root.walkDecls(d => {\n          d.important = important;\n        });\n      });\n\n      const mergedRules = mergeAdjacentRules(nearestParentRule, [...nodes, afterRule]);\n      applyRule.remove();\n      parent.after(mergedRules); // If the base rule has nothing in it (all applys were pseudo or responsive variants),\n      // remove the rule fuggit.\n\n      if (parent.nodes.length === 0) {\n        parent.remove();\n      }\n    }); // We already know that we have at least 1 @apply rule. Otherwise this\n    // function would not have been called. Therefore we can execute this code\n    // at least once. This also means that in the best case scenario we only\n    // call this 2 times, instead of 3 times.\n    // 1st time -> before we call this function\n    // 2nd time -> when we check if we have to do this loop again (because do {} while (check))\n    // .. instead of\n    // 1st time -> before we call this function\n    // 2nd time -> when we check the first time (because while (check) do {})\n    // 3rd time -> when we re-check to see if we should do this loop again\n  } while (hasAtRule(css, 'apply'));\n\n  return css;\n}\n\nlet defaultTailwindTree = new Map();\n\nfunction substituteClassApplyAtRules(config, getProcessedPlugins, configChanged) {\n  return function (css) {\n    // We can stop already when we don't have any @apply rules. Vue users: you're welcome!\n    if (!hasAtRule(css, 'apply')) {\n      return css;\n    }\n\n    let requiredTailwindAtRules = ['base', 'components', 'utilities'];\n\n    if (hasAtRule(css, 'tailwind', node => {\n      let idx = requiredTailwindAtRules.indexOf(node.params);\n      if (idx !== -1) requiredTailwindAtRules.splice(idx, 1);\n      if (requiredTailwindAtRules.length <= 0) return true;\n      return false;\n    })) {\n      // Tree already contains all the at rules (requiredTailwindAtRules)\n      return processApplyAtRules(css, _postcss.default.root(), config);\n    }\n\n    let lookupKey = requiredTailwindAtRules.join(','); // We mutated the `requiredTailwindAtRules`, but when we hit this point in\n    // time, it means that we don't have all the atrules. The missing atrules\n    // are listed inside the requiredTailwindAtRules, which we can use to fill\n    // in the missing pieces.\n    //\n    // Important for <style> blocks in Vue components.\n\n    const generateLookupTree = configChanged || !defaultTailwindTree.has(lookupKey) ? () => {\n      return (0, _postcss.default)([(0, _substituteTailwindAtRules.default)(config, getProcessedPlugins()), (0, _evaluateTailwindFunctions.default)({\n        tailwindConfig: config\n      }), (0, _substituteVariantsAtRules.default)(config, getProcessedPlugins()), (0, _substituteResponsiveAtRules.default)(config), (0, _convertLayerAtRulesToControlComments.default)(config), (0, _substituteScreenAtRules.default)({\n        tailwindConfig: config\n      })]).process(requiredTailwindAtRules.map(rule => `@tailwind ${rule};`).join('\\n'), {\n        from: __filename\n      }).then(result => {\n        defaultTailwindTree.set(lookupKey, result);\n        return result;\n      });\n    } : () => Promise.resolve(defaultTailwindTree.get(lookupKey));\n    return generateLookupTree().then(result => {\n      return processApplyAtRules(css, result.root, config);\n    });\n  };\n}","map":{"version":3,"sources":["/home/alan/delivery_2/previously_on/client/node_modules/tailwindcss/lib/lib/substituteClassApplyAtRules.js"],"names":["Object","defineProperty","exports","value","default","substituteClassApplyAtRules","_lodash","_interopRequireDefault","require","_postcssSelectorParser","_postcss","_didyoumean","_substituteTailwindAtRules","_evaluateTailwindFunctions","_substituteVariantsAtRules","_substituteResponsiveAtRules","_convertLayerAtRulesToControlComments","_substituteScreenAtRules","_prefixSelector","_useMemo","obj","__esModule","hasAtRule","css","atRule","condition","found","walkAtRules","undefined","node","cloneWithoutChildren","type","name","params","rule","selectors","clone","removeAll","tailwindApplyPlaceholder","attribute","generateRulesFromApply","utilityName","className","classPosition","replaceWiths","parser","i","walkClasses","c","replaceWith","processedSelectors","flatMap","selector","map","processSync","replace","cloned","current","parent","parentClone","append","extractUtilityNamesParser","classes","push","extractUtilityNames","useMemo","transformSync","cloneRuleWithParent","buildCssUtilityMap","startIndex","index","utilityMap","handle","getRule","utilityNames","forEach","walkRules","bind","buildLookupTreeUtilityMap","lookupTree","tree","mergeAdjacentRules","initialRule","rulesToInsert","previousRule","toInsert","nodes","merged","length","walk","n","remove","filter","r","makeExtractUtilityRules","config","lookupTreeUtilityMap","lookupTreeUtilityMapKeys","keys","getUtility","utility","extractUtilityRules","combined","prefixedUtilityName","prefix","slice","prefixedUtility","error","suggestedClass","concat","suggestionMessage","word","sort","a","b","findParent","predicate","Error","processApplyAtRules","applyRule","nearestParentRule","currentUtilityNames","importantEntries","applyUtilityNames","important","partition","split","intersection","currentUtilityName","afterRule","raws","applys","util","__tailwind","tap","root","walkDecls","d","mergedRules","after","defaultTailwindTree","Map","getProcessedPlugins","configChanged","requiredTailwindAtRules","idx","indexOf","splice","lookupKey","join","generateLookupTree","has","tailwindConfig","process","from","__filename","then","result","set","Promise","resolve","get"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = substituteClassApplyAtRules;\n\nvar _lodash = _interopRequireDefault(require(\"lodash\"));\n\nvar _postcssSelectorParser = _interopRequireDefault(require(\"postcss-selector-parser\"));\n\nvar _postcss = _interopRequireDefault(require(\"postcss\"));\n\nvar _didyoumean = _interopRequireDefault(require(\"didyoumean\"));\n\nvar _substituteTailwindAtRules = _interopRequireDefault(require(\"./substituteTailwindAtRules\"));\n\nvar _evaluateTailwindFunctions = _interopRequireDefault(require(\"./evaluateTailwindFunctions\"));\n\nvar _substituteVariantsAtRules = _interopRequireDefault(require(\"./substituteVariantsAtRules\"));\n\nvar _substituteResponsiveAtRules = _interopRequireDefault(require(\"./substituteResponsiveAtRules\"));\n\nvar _convertLayerAtRulesToControlComments = _interopRequireDefault(require(\"./convertLayerAtRulesToControlComments\"));\n\nvar _substituteScreenAtRules = _interopRequireDefault(require(\"./substituteScreenAtRules\"));\n\nvar _prefixSelector = _interopRequireDefault(require(\"../util/prefixSelector\"));\n\nvar _useMemo = require(\"../util/useMemo\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction hasAtRule(css, atRule, condition) {\n  let found = false;\n  css.walkAtRules(atRule, condition === undefined ? () => {\n    found = true;\n    return false;\n  } : node => {\n    if (condition(node)) {\n      found = true;\n      return false;\n    }\n  });\n  return found;\n}\n\nfunction cloneWithoutChildren(node) {\n  if (node.type === 'atrule') {\n    return _postcss.default.atRule({\n      name: node.name,\n      params: node.params\n    });\n  }\n\n  if (node.type === 'rule') {\n    return _postcss.default.rule({\n      name: node.name,\n      selectors: node.selectors\n    });\n  }\n\n  const clone = node.clone();\n  clone.removeAll();\n  return clone;\n}\n\nconst tailwindApplyPlaceholder = _postcssSelectorParser.default.attribute({\n  attribute: '__TAILWIND-APPLY-PLACEHOLDER__'\n});\n\nfunction generateRulesFromApply({\n  rule,\n  utilityName: className,\n  classPosition\n}, replaceWiths) {\n  const parser = (0, _postcssSelectorParser.default)(selectors => {\n    let i = 0;\n    selectors.walkClasses(c => {\n      if (classPosition === i++ && c.value === className) {\n        c.replaceWith(tailwindApplyPlaceholder);\n      }\n    });\n  });\n\n  const processedSelectors = _lodash.default.flatMap(rule.selectors, selector => {\n    // You could argue we should make this replacement at the AST level, but if we believe\n    // the placeholder string is safe from collisions then it is safe to do this is a simple\n    // string replacement, and much, much faster.\n    return replaceWiths.map(replaceWith => parser.processSync(selector).replace('[__TAILWIND-APPLY-PLACEHOLDER__]', replaceWith));\n  });\n\n  const cloned = rule.clone();\n  let current = cloned;\n  let parent = rule.parent;\n\n  while (parent && parent.type !== 'root') {\n    const parentClone = cloneWithoutChildren(parent);\n    parentClone.append(current);\n    current.parent = parentClone;\n    current = parentClone;\n    parent = parent.parent;\n  }\n\n  cloned.selectors = processedSelectors;\n  return current;\n}\n\nconst extractUtilityNamesParser = (0, _postcssSelectorParser.default)(selectors => {\n  let classes = [];\n  selectors.walkClasses(c => classes.push(c.value));\n  return classes;\n});\nconst extractUtilityNames = (0, _useMemo.useMemo)(selector => extractUtilityNamesParser.transformSync(selector), selector => selector);\nconst cloneRuleWithParent = (0, _useMemo.useMemo)(rule => rule.clone({\n  parent: rule.parent\n}), rule => rule);\n\nfunction buildCssUtilityMap(css, startIndex) {\n  let index = startIndex;\n  const utilityMap = {};\n\n  function handle(getRule, rule) {\n    const utilityNames = extractUtilityNames(rule.selector);\n    utilityNames.forEach((utilityName, i) => {\n      if (utilityMap[utilityName] === undefined) {\n        utilityMap[utilityName] = [];\n      }\n\n      utilityMap[utilityName].push({\n        index,\n        utilityName,\n        classPosition: i,\n        ...getRule(rule)\n      });\n      index++;\n    });\n  } // This is the end user's css. This might contain rules that we want to\n  // apply. We want immediate copies of everything in case that we have user\n  // defined classes that are recursively applied. Down below we are modifying\n  // the rules directly. We could do a better solution where we keep track of a\n  // dependency tree, but that is a bit more complex. Might revisit later,\n  // we'll see how this turns out!\n\n\n  css.walkRules(handle.bind(null, rule => ({\n    rule: cloneRuleWithParent(rule)\n  })));\n  return utilityMap;\n}\n\nconst buildLookupTreeUtilityMap = (0, _useMemo.useMemo)(lookupTree => {\n  let index = 0;\n  const utilityMap = {};\n\n  function handle(getRule, rule) {\n    const utilityNames = extractUtilityNames(rule.selector);\n    utilityNames.forEach((utilityName, i) => {\n      if (utilityMap[utilityName] === undefined) {\n        utilityMap[utilityName] = [];\n      }\n\n      utilityMap[utilityName].push({\n        index,\n        utilityName,\n        classPosition: i,\n        ...getRule(rule)\n      });\n      index++;\n    });\n  } // Lookup tree is the big lookup tree, making the rule lazy allows us to save\n  // some memory because we don't need everything.\n\n\n  lookupTree.walkRules(handle.bind(null, rule => ({\n    get rule() {\n      return cloneRuleWithParent(rule);\n    }\n\n  })));\n  return utilityMap;\n}, tree => tree);\n\nfunction mergeAdjacentRules(initialRule, rulesToInsert) {\n  let previousRule = initialRule;\n  rulesToInsert.forEach(toInsert => {\n    if (toInsert.type === 'rule' && previousRule.type === 'rule' && toInsert.selector === previousRule.selector) {\n      previousRule.append(toInsert.nodes);\n    } else if (toInsert.type === 'atrule' && previousRule.type === 'atrule' && toInsert.params === previousRule.params) {\n      const merged = mergeAdjacentRules(previousRule.nodes[previousRule.nodes.length - 1], toInsert.nodes);\n      previousRule.append(merged);\n    } else {\n      previousRule = toInsert;\n    }\n\n    toInsert.walk(n => {\n      if (n.nodes && n.nodes.length === 0) {\n        n.remove();\n      }\n    });\n  });\n  return rulesToInsert.filter(r => r.nodes.length > 0);\n}\n\nfunction makeExtractUtilityRules(css, lookupTree, config) {\n  const lookupTreeUtilityMap = buildLookupTreeUtilityMap(lookupTree);\n  const lookupTreeUtilityMapKeys = Object.keys(lookupTreeUtilityMap);\n  const utilityMap = buildCssUtilityMap(css, lookupTreeUtilityMapKeys.length);\n\n  function getUtility(utilityName) {\n    const utility = [];\n\n    if (lookupTreeUtilityMap[utilityName]) {\n      utility.push(...lookupTreeUtilityMap[utilityName]);\n    }\n\n    if (utilityMap[utilityName]) {\n      utility.push(...utilityMap[utilityName]);\n    }\n\n    if (utility.length > 0) return utility;\n  }\n\n  return function extractUtilityRules(utilityNames, rule) {\n    const combined = [];\n    utilityNames.forEach(utilityName => {\n      const utility = getUtility(utilityName);\n\n      if (utility === undefined) {\n        // Look for prefixed utility in case the user has goofed\n        const prefixedUtilityName = (0, _prefixSelector.default)(config.prefix, `.${utilityName}`).slice(1);\n        const prefixedUtility = getUtility(prefixedUtilityName);\n\n        if (prefixedUtility !== undefined) {\n          throw rule.error(`The \\`${utilityName}\\` class does not exist, but \\`${prefixedUtilityName}\\` does. Did you forget the prefix?`);\n        }\n\n        const suggestedClass = (0, _didyoumean.default)(utilityName, Object.keys(utilityMap).concat(lookupTreeUtilityMapKeys));\n        const suggestionMessage = suggestedClass ? `, but \\`${suggestedClass}\\` does` : '';\n        throw rule.error(`The \\`${utilityName}\\` class does not exist${suggestionMessage}. If you're sure that \\`${utilityName}\\` exists, make sure that any \\`@import\\` statements are being properly processed before Tailwind CSS sees your CSS, as \\`@apply\\` can only be used for classes in the same CSS tree.`, {\n          word: utilityName\n        });\n      }\n\n      combined.push(...utility);\n    });\n    return combined.sort((a, b) => a.index - b.index);\n  };\n}\n\nfunction findParent(rule, predicate) {\n  let parent = rule.parent;\n\n  while (parent) {\n    if (predicate(parent)) {\n      return parent;\n    }\n\n    parent = parent.parent;\n  }\n\n  throw new Error('No parent could be found');\n}\n\nfunction processApplyAtRules(css, lookupTree, config) {\n  const extractUtilityRules = makeExtractUtilityRules(css, lookupTree, config);\n\n  do {\n    css.walkAtRules('apply', applyRule => {\n      const parent = applyRule.parent; // Direct parent\n\n      const nearestParentRule = findParent(applyRule, r => r.type === 'rule');\n      const currentUtilityNames = extractUtilityNames(nearestParentRule.selector);\n\n      const [importantEntries, applyUtilityNames, important = importantEntries.length > 0] = _lodash.default.partition(applyRule.params.split(/[\\s\\t\\n]+/g), n => n === '!important');\n\n      if (_lodash.default.intersection(applyUtilityNames, currentUtilityNames).length > 0) {\n        const currentUtilityName = _lodash.default.intersection(applyUtilityNames, currentUtilityNames)[0];\n\n        throw parent.error(`You cannot \\`@apply\\` the \\`${currentUtilityName}\\` utility here because it creates a circular dependency.`);\n      } // Extract any post-apply declarations and re-insert them after apply rules\n\n\n      const afterRule = parent.clone({\n        raws: {}\n      });\n      afterRule.nodes = afterRule.nodes.slice(parent.index(applyRule) + 1);\n      parent.nodes = parent.nodes.slice(0, parent.index(applyRule) + 1); // Sort applys to match CSS source order\n\n      const applys = extractUtilityRules(applyUtilityNames, applyRule); // Get new rules with the utility portion of the selector replaced with the new selector\n\n      const rulesToInsert = [];\n      applys.forEach(nearestParentRule === parent ? util => rulesToInsert.push(generateRulesFromApply(util, parent.selectors)) : util => util.rule.nodes.forEach(n => afterRule.append(n.clone())));\n      rulesToInsert.forEach(rule => {\n        if (rule.type === 'atrule') {\n          rule.walkRules(rule => {\n            rule.__tailwind = { ...rule.__tailwind,\n              important\n            };\n          });\n        } else {\n          rule.__tailwind = { ...rule.__tailwind,\n            important\n          };\n        }\n      });\n\n      const {\n        nodes\n      } = _lodash.default.tap(_postcss.default.root({\n        nodes: rulesToInsert\n      }), root => {\n        root.walkDecls(d => {\n          d.important = important;\n        });\n      });\n\n      const mergedRules = mergeAdjacentRules(nearestParentRule, [...nodes, afterRule]);\n      applyRule.remove();\n      parent.after(mergedRules); // If the base rule has nothing in it (all applys were pseudo or responsive variants),\n      // remove the rule fuggit.\n\n      if (parent.nodes.length === 0) {\n        parent.remove();\n      }\n    }); // We already know that we have at least 1 @apply rule. Otherwise this\n    // function would not have been called. Therefore we can execute this code\n    // at least once. This also means that in the best case scenario we only\n    // call this 2 times, instead of 3 times.\n    // 1st time -> before we call this function\n    // 2nd time -> when we check if we have to do this loop again (because do {} while (check))\n    // .. instead of\n    // 1st time -> before we call this function\n    // 2nd time -> when we check the first time (because while (check) do {})\n    // 3rd time -> when we re-check to see if we should do this loop again\n  } while (hasAtRule(css, 'apply'));\n\n  return css;\n}\n\nlet defaultTailwindTree = new Map();\n\nfunction substituteClassApplyAtRules(config, getProcessedPlugins, configChanged) {\n  return function (css) {\n    // We can stop already when we don't have any @apply rules. Vue users: you're welcome!\n    if (!hasAtRule(css, 'apply')) {\n      return css;\n    }\n\n    let requiredTailwindAtRules = ['base', 'components', 'utilities'];\n\n    if (hasAtRule(css, 'tailwind', node => {\n      let idx = requiredTailwindAtRules.indexOf(node.params);\n      if (idx !== -1) requiredTailwindAtRules.splice(idx, 1);\n      if (requiredTailwindAtRules.length <= 0) return true;\n      return false;\n    })) {\n      // Tree already contains all the at rules (requiredTailwindAtRules)\n      return processApplyAtRules(css, _postcss.default.root(), config);\n    }\n\n    let lookupKey = requiredTailwindAtRules.join(','); // We mutated the `requiredTailwindAtRules`, but when we hit this point in\n    // time, it means that we don't have all the atrules. The missing atrules\n    // are listed inside the requiredTailwindAtRules, which we can use to fill\n    // in the missing pieces.\n    //\n    // Important for <style> blocks in Vue components.\n\n    const generateLookupTree = configChanged || !defaultTailwindTree.has(lookupKey) ? () => {\n      return (0, _postcss.default)([(0, _substituteTailwindAtRules.default)(config, getProcessedPlugins()), (0, _evaluateTailwindFunctions.default)({\n        tailwindConfig: config\n      }), (0, _substituteVariantsAtRules.default)(config, getProcessedPlugins()), (0, _substituteResponsiveAtRules.default)(config), (0, _convertLayerAtRulesToControlComments.default)(config), (0, _substituteScreenAtRules.default)({\n        tailwindConfig: config\n      })]).process(requiredTailwindAtRules.map(rule => `@tailwind ${rule};`).join('\\n'), {\n        from: __filename\n      }).then(result => {\n        defaultTailwindTree.set(lookupKey, result);\n        return result;\n      });\n    } : () => Promise.resolve(defaultTailwindTree.get(lookupKey));\n    return generateLookupTree().then(result => {\n      return processApplyAtRules(css, result.root, config);\n    });\n  };\n}"]},"metadata":{},"sourceType":"script"}