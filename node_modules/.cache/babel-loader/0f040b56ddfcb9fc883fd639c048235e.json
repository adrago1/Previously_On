{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveMatches = resolveMatches;\nexports.generateRules = generateRules;\n\nvar _postcss = _interopRequireDefault(require(\"postcss\"));\n\nvar _postcssSelectorParser = _interopRequireDefault(require(\"postcss-selector-parser\"));\n\nvar _parseObjectStyles = _interopRequireDefault(require(\"../../util/parseObjectStyles\"));\n\nvar _isPlainObject = _interopRequireDefault(require(\"../../util/isPlainObject\"));\n\nvar _prefixSelector = _interopRequireDefault(require(\"../../util/prefixSelector\"));\n\nvar _pluginUtils = require(\"../../util/pluginUtils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nlet classNameParser = (0, _postcssSelectorParser.default)(selectors => {\n  return selectors.first.filter(({\n    type\n  }) => type === 'class').pop().value;\n});\n\nfunction getClassNameFromSelector(selector) {\n  return classNameParser.transformSync(selector);\n} // Generate match permutations for a class candidate, like:\n// ['ring-offset-blue', '100']\n// ['ring-offset', 'blue-100']\n// ['ring', 'offset-blue-100']\n// Example with dynamic classes:\n// ['grid-cols', '[[linename],1fr,auto]']\n// ['grid', 'cols-[[linename],1fr,auto]']\n\n\nfunction* candidatePermutations(candidate, lastIndex = Infinity) {\n  if (lastIndex < 0) {\n    return;\n  }\n\n  let dashIdx;\n\n  if (lastIndex === Infinity && candidate.endsWith(']')) {\n    let bracketIdx = candidate.indexOf('['); // If character before `[` isn't a dash or a slash, this isn't a dynamic class\n    // eg. string[]\n\n    dashIdx = ['-', '/'].includes(candidate[bracketIdx - 1]) ? bracketIdx - 1 : -1;\n  } else {\n    dashIdx = candidate.lastIndexOf('-', lastIndex);\n  }\n\n  if (dashIdx < 0) {\n    return;\n  }\n\n  let prefix = candidate.slice(0, dashIdx);\n  let modifier = candidate.slice(dashIdx + 1);\n  yield [prefix, modifier];\n  yield* candidatePermutations(candidate, dashIdx - 1);\n}\n\nfunction applyPrefix(matches, context) {\n  if (matches.length === 0 || context.tailwindConfig.prefix === '') {\n    return matches;\n  }\n\n  for (let match of matches) {\n    let [meta] = match;\n\n    if (meta.options.respectPrefix) {\n      let container = _postcss.default.root({\n        nodes: [match[1].clone()]\n      });\n\n      container.walkRules(r => {\n        r.selector = (0, _prefixSelector.default)(context.tailwindConfig.prefix, r.selector);\n      });\n      match[1] = container.nodes[0];\n    }\n  }\n\n  return matches;\n}\n\nfunction applyImportant(matches) {\n  if (matches.length === 0) {\n    return matches;\n  }\n\n  let result = [];\n\n  for (let [meta, rule] of matches) {\n    let container = _postcss.default.root({\n      nodes: [rule.clone()]\n    });\n\n    container.walkRules(r => {\n      r.selector = (0, _pluginUtils.updateAllClasses)(r.selector, className => {\n        return `!${className}`;\n      });\n      r.walkDecls(d => d.important = true);\n    });\n    result.push([{ ...meta,\n      important: true\n    }, container.nodes[0]]);\n  }\n\n  return result;\n} // Takes a list of rule tuples and applies a variant like `hover`, sm`,\n// whatever to it. We used to do some extra caching here to avoid generating\n// a variant of the same rule more than once, but this was never hit because\n// we cache at the entire selector level further up the tree.\n//\n// Technically you can get a cache hit if you have `hover:focus:text-center`\n// and `focus:hover:text-center` in the same project, but it doesn't feel\n// worth the complexity for that case.\n\n\nfunction applyVariant(variant, matches, context) {\n  if (matches.length === 0) {\n    return matches;\n  }\n\n  if (context.variantMap.has(variant)) {\n    let variantFunctionTuples = context.variantMap.get(variant);\n    let result = [];\n\n    for (let [meta, rule] of matches) {\n      if (meta.options.respectVariants === false) {\n        result.push([meta, rule]);\n        continue;\n      }\n\n      let container = _postcss.default.root({\n        nodes: [rule.clone()]\n      });\n\n      for (let [variantSort, variantFunction] of variantFunctionTuples) {\n        let clone = container.clone();\n\n        function modifySelectors(modifierFunction) {\n          clone.each(rule => {\n            if (rule.type !== 'rule') {\n              return;\n            }\n\n            rule.selectors = rule.selectors.map(selector => {\n              return modifierFunction({\n                get className() {\n                  return getClassNameFromSelector(selector);\n                },\n\n                selector\n              });\n            });\n          });\n          return clone;\n        }\n\n        let ruleWithVariant = variantFunction({\n          container: clone,\n          separator: context.tailwindConfig.separator,\n          modifySelectors\n        });\n\n        if (ruleWithVariant === null) {\n          continue;\n        }\n\n        let withOffset = [{ ...meta,\n          sort: variantSort | meta.sort\n        }, clone.nodes[0]];\n        result.push(withOffset);\n      }\n    }\n\n    return result;\n  }\n\n  return [];\n}\n\nfunction parseRules(rule, cache, options = {}) {\n  // PostCSS node\n  if (!(0, _isPlainObject.default)(rule) && !Array.isArray(rule)) {\n    return [[rule], options];\n  } // Tuple\n\n\n  if (Array.isArray(rule)) {\n    return parseRules(rule[0], cache, rule[1]);\n  } // Simple object\n\n\n  if (!cache.has(rule)) {\n    cache.set(rule, (0, _parseObjectStyles.default)(rule));\n  }\n\n  return [cache.get(rule), options];\n}\n\nfunction* resolveMatchedPlugins(classCandidate, context) {\n  if (context.candidateRuleMap.has(classCandidate)) {\n    yield [context.candidateRuleMap.get(classCandidate), 'DEFAULT'];\n  }\n\n  let candidatePrefix = classCandidate;\n  let negative = false;\n  const twConfigPrefix = context.tailwindConfig.prefix || '';\n  const twConfigPrefixLen = twConfigPrefix.length;\n\n  if (candidatePrefix[twConfigPrefixLen] === '-') {\n    negative = true;\n    candidatePrefix = twConfigPrefix + candidatePrefix.slice(twConfigPrefixLen + 1);\n  }\n\n  for (let [prefix, modifier] of candidatePermutations(candidatePrefix)) {\n    if (context.candidateRuleMap.has(prefix)) {\n      yield [context.candidateRuleMap.get(prefix), negative ? `-${modifier}` : modifier];\n      return;\n    }\n  }\n}\n\nfunction splitWithSeparator(input, separator) {\n  return input.split(new RegExp(`\\\\${separator}(?![^[]*\\\\])`, 'g'));\n}\n\nfunction* resolveMatches(candidate, context) {\n  let separator = context.tailwindConfig.separator;\n  let [classCandidate, ...variants] = splitWithSeparator(candidate, separator).reverse();\n  let important = false;\n\n  if (classCandidate.startsWith('!')) {\n    important = true;\n    classCandidate = classCandidate.slice(1);\n  } // TODO: Reintroduce this in ways that doesn't break on false positives\n  // function sortAgainst(toSort, against) {\n  //   return toSort.slice().sort((a, z) => {\n  //     return bigSign(against.get(a)[0] - against.get(z)[0])\n  //   })\n  // }\n  // let sorted = sortAgainst(variants, context.variantMap)\n  // if (sorted.toString() !== variants.toString()) {\n  //   let corrected = sorted.reverse().concat(classCandidate).join(':')\n  //   throw new Error(`Class ${candidate} should be written as ${corrected}`)\n  // }\n\n\n  for (let matchedPlugins of resolveMatchedPlugins(classCandidate, context)) {\n    let matches = [];\n    let [plugins, modifier] = matchedPlugins;\n\n    for (let [sort, plugin] of plugins) {\n      if (typeof plugin === 'function') {\n        for (let ruleSet of [].concat(plugin(modifier))) {\n          let [rules, options] = parseRules(ruleSet, context.postCssNodeCache);\n\n          for (let rule of rules) {\n            matches.push([{ ...sort,\n              options: { ...sort.options,\n                ...options\n              }\n            }, rule]);\n          }\n        }\n      } // Only process static plugins on exact matches\n      else if (modifier === 'DEFAULT') {\n          let ruleSet = plugin;\n          let [rules, options] = parseRules(ruleSet, context.postCssNodeCache);\n\n          for (let rule of rules) {\n            matches.push([{ ...sort,\n              options: { ...sort.options,\n                ...options\n              }\n            }, rule]);\n          }\n        }\n    }\n\n    matches = applyPrefix(matches, context);\n\n    if (important) {\n      matches = applyImportant(matches, context);\n    }\n\n    for (let variant of variants) {\n      matches = applyVariant(variant, matches, context);\n    }\n\n    for (let match of matches) {\n      yield match;\n    }\n  }\n}\n\nfunction inKeyframes(rule) {\n  return rule.parent && rule.parent.type === 'atrule' && rule.parent.name === 'keyframes';\n}\n\nfunction generateRules(candidates, context) {\n  let allRules = [];\n\n  for (let candidate of candidates) {\n    if (context.notClassCache.has(candidate)) {\n      continue;\n    }\n\n    if (context.classCache.has(candidate)) {\n      allRules.push(context.classCache.get(candidate));\n      continue;\n    }\n\n    let matches = Array.from(resolveMatches(candidate, context));\n\n    if (matches.length === 0) {\n      context.notClassCache.add(candidate);\n      continue;\n    }\n\n    context.classCache.set(candidate, matches);\n    allRules.push(matches);\n  }\n\n  return allRules.flat(1).map(([{\n    sort,\n    layer,\n    options\n  }, rule]) => {\n    if (options.respectImportant) {\n      if (context.tailwindConfig.important === true) {\n        rule.walkDecls(d => {\n          if (d.parent.type === 'rule' && !inKeyframes(d.parent)) {\n            d.important = true;\n          }\n        });\n      } else if (typeof context.tailwindConfig.important === 'string') {\n        let container = _postcss.default.root({\n          nodes: [rule.clone()]\n        });\n\n        container.walkRules(r => {\n          if (inKeyframes(r)) {\n            return;\n          }\n\n          r.selectors = r.selectors.map(selector => {\n            return `${context.tailwindConfig.important} ${selector}`;\n          });\n        });\n        rule = container.nodes[0];\n      }\n    }\n\n    return [sort | context.layerOrder[layer], rule];\n  });\n}","map":{"version":3,"sources":["/home/alan/delivery_2/previously_on/client/node_modules/tailwindcss/lib/jit/lib/generateRules.js"],"names":["Object","defineProperty","exports","value","resolveMatches","generateRules","_postcss","_interopRequireDefault","require","_postcssSelectorParser","_parseObjectStyles","_isPlainObject","_prefixSelector","_pluginUtils","obj","__esModule","default","classNameParser","selectors","first","filter","type","pop","getClassNameFromSelector","selector","transformSync","candidatePermutations","candidate","lastIndex","Infinity","dashIdx","endsWith","bracketIdx","indexOf","includes","lastIndexOf","prefix","slice","modifier","applyPrefix","matches","context","length","tailwindConfig","match","meta","options","respectPrefix","container","root","nodes","clone","walkRules","r","applyImportant","result","rule","updateAllClasses","className","walkDecls","d","important","push","applyVariant","variant","variantMap","has","variantFunctionTuples","get","respectVariants","variantSort","variantFunction","modifySelectors","modifierFunction","each","map","ruleWithVariant","separator","withOffset","sort","parseRules","cache","Array","isArray","set","resolveMatchedPlugins","classCandidate","candidateRuleMap","candidatePrefix","negative","twConfigPrefix","twConfigPrefixLen","splitWithSeparator","input","split","RegExp","variants","reverse","startsWith","matchedPlugins","plugins","plugin","ruleSet","concat","rules","postCssNodeCache","inKeyframes","parent","name","candidates","allRules","notClassCache","classCache","from","add","flat","layer","respectImportant","layerOrder"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveMatches = resolveMatches;\nexports.generateRules = generateRules;\n\nvar _postcss = _interopRequireDefault(require(\"postcss\"));\n\nvar _postcssSelectorParser = _interopRequireDefault(require(\"postcss-selector-parser\"));\n\nvar _parseObjectStyles = _interopRequireDefault(require(\"../../util/parseObjectStyles\"));\n\nvar _isPlainObject = _interopRequireDefault(require(\"../../util/isPlainObject\"));\n\nvar _prefixSelector = _interopRequireDefault(require(\"../../util/prefixSelector\"));\n\nvar _pluginUtils = require(\"../../util/pluginUtils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nlet classNameParser = (0, _postcssSelectorParser.default)(selectors => {\n  return selectors.first.filter(({\n    type\n  }) => type === 'class').pop().value;\n});\n\nfunction getClassNameFromSelector(selector) {\n  return classNameParser.transformSync(selector);\n} // Generate match permutations for a class candidate, like:\n// ['ring-offset-blue', '100']\n// ['ring-offset', 'blue-100']\n// ['ring', 'offset-blue-100']\n// Example with dynamic classes:\n// ['grid-cols', '[[linename],1fr,auto]']\n// ['grid', 'cols-[[linename],1fr,auto]']\n\n\nfunction* candidatePermutations(candidate, lastIndex = Infinity) {\n  if (lastIndex < 0) {\n    return;\n  }\n\n  let dashIdx;\n\n  if (lastIndex === Infinity && candidate.endsWith(']')) {\n    let bracketIdx = candidate.indexOf('['); // If character before `[` isn't a dash or a slash, this isn't a dynamic class\n    // eg. string[]\n\n    dashIdx = ['-', '/'].includes(candidate[bracketIdx - 1]) ? bracketIdx - 1 : -1;\n  } else {\n    dashIdx = candidate.lastIndexOf('-', lastIndex);\n  }\n\n  if (dashIdx < 0) {\n    return;\n  }\n\n  let prefix = candidate.slice(0, dashIdx);\n  let modifier = candidate.slice(dashIdx + 1);\n  yield [prefix, modifier];\n  yield* candidatePermutations(candidate, dashIdx - 1);\n}\n\nfunction applyPrefix(matches, context) {\n  if (matches.length === 0 || context.tailwindConfig.prefix === '') {\n    return matches;\n  }\n\n  for (let match of matches) {\n    let [meta] = match;\n\n    if (meta.options.respectPrefix) {\n      let container = _postcss.default.root({\n        nodes: [match[1].clone()]\n      });\n\n      container.walkRules(r => {\n        r.selector = (0, _prefixSelector.default)(context.tailwindConfig.prefix, r.selector);\n      });\n      match[1] = container.nodes[0];\n    }\n  }\n\n  return matches;\n}\n\nfunction applyImportant(matches) {\n  if (matches.length === 0) {\n    return matches;\n  }\n\n  let result = [];\n\n  for (let [meta, rule] of matches) {\n    let container = _postcss.default.root({\n      nodes: [rule.clone()]\n    });\n\n    container.walkRules(r => {\n      r.selector = (0, _pluginUtils.updateAllClasses)(r.selector, className => {\n        return `!${className}`;\n      });\n      r.walkDecls(d => d.important = true);\n    });\n    result.push([{ ...meta,\n      important: true\n    }, container.nodes[0]]);\n  }\n\n  return result;\n} // Takes a list of rule tuples and applies a variant like `hover`, sm`,\n// whatever to it. We used to do some extra caching here to avoid generating\n// a variant of the same rule more than once, but this was never hit because\n// we cache at the entire selector level further up the tree.\n//\n// Technically you can get a cache hit if you have `hover:focus:text-center`\n// and `focus:hover:text-center` in the same project, but it doesn't feel\n// worth the complexity for that case.\n\n\nfunction applyVariant(variant, matches, context) {\n  if (matches.length === 0) {\n    return matches;\n  }\n\n  if (context.variantMap.has(variant)) {\n    let variantFunctionTuples = context.variantMap.get(variant);\n    let result = [];\n\n    for (let [meta, rule] of matches) {\n      if (meta.options.respectVariants === false) {\n        result.push([meta, rule]);\n        continue;\n      }\n\n      let container = _postcss.default.root({\n        nodes: [rule.clone()]\n      });\n\n      for (let [variantSort, variantFunction] of variantFunctionTuples) {\n        let clone = container.clone();\n\n        function modifySelectors(modifierFunction) {\n          clone.each(rule => {\n            if (rule.type !== 'rule') {\n              return;\n            }\n\n            rule.selectors = rule.selectors.map(selector => {\n              return modifierFunction({\n                get className() {\n                  return getClassNameFromSelector(selector);\n                },\n\n                selector\n              });\n            });\n          });\n          return clone;\n        }\n\n        let ruleWithVariant = variantFunction({\n          container: clone,\n          separator: context.tailwindConfig.separator,\n          modifySelectors\n        });\n\n        if (ruleWithVariant === null) {\n          continue;\n        }\n\n        let withOffset = [{ ...meta,\n          sort: variantSort | meta.sort\n        }, clone.nodes[0]];\n        result.push(withOffset);\n      }\n    }\n\n    return result;\n  }\n\n  return [];\n}\n\nfunction parseRules(rule, cache, options = {}) {\n  // PostCSS node\n  if (!(0, _isPlainObject.default)(rule) && !Array.isArray(rule)) {\n    return [[rule], options];\n  } // Tuple\n\n\n  if (Array.isArray(rule)) {\n    return parseRules(rule[0], cache, rule[1]);\n  } // Simple object\n\n\n  if (!cache.has(rule)) {\n    cache.set(rule, (0, _parseObjectStyles.default)(rule));\n  }\n\n  return [cache.get(rule), options];\n}\n\nfunction* resolveMatchedPlugins(classCandidate, context) {\n  if (context.candidateRuleMap.has(classCandidate)) {\n    yield [context.candidateRuleMap.get(classCandidate), 'DEFAULT'];\n  }\n\n  let candidatePrefix = classCandidate;\n  let negative = false;\n  const twConfigPrefix = context.tailwindConfig.prefix || '';\n  const twConfigPrefixLen = twConfigPrefix.length;\n\n  if (candidatePrefix[twConfigPrefixLen] === '-') {\n    negative = true;\n    candidatePrefix = twConfigPrefix + candidatePrefix.slice(twConfigPrefixLen + 1);\n  }\n\n  for (let [prefix, modifier] of candidatePermutations(candidatePrefix)) {\n    if (context.candidateRuleMap.has(prefix)) {\n      yield [context.candidateRuleMap.get(prefix), negative ? `-${modifier}` : modifier];\n      return;\n    }\n  }\n}\n\nfunction splitWithSeparator(input, separator) {\n  return input.split(new RegExp(`\\\\${separator}(?![^[]*\\\\])`, 'g'));\n}\n\nfunction* resolveMatches(candidate, context) {\n  let separator = context.tailwindConfig.separator;\n  let [classCandidate, ...variants] = splitWithSeparator(candidate, separator).reverse();\n  let important = false;\n\n  if (classCandidate.startsWith('!')) {\n    important = true;\n    classCandidate = classCandidate.slice(1);\n  } // TODO: Reintroduce this in ways that doesn't break on false positives\n  // function sortAgainst(toSort, against) {\n  //   return toSort.slice().sort((a, z) => {\n  //     return bigSign(against.get(a)[0] - against.get(z)[0])\n  //   })\n  // }\n  // let sorted = sortAgainst(variants, context.variantMap)\n  // if (sorted.toString() !== variants.toString()) {\n  //   let corrected = sorted.reverse().concat(classCandidate).join(':')\n  //   throw new Error(`Class ${candidate} should be written as ${corrected}`)\n  // }\n\n\n  for (let matchedPlugins of resolveMatchedPlugins(classCandidate, context)) {\n    let matches = [];\n    let [plugins, modifier] = matchedPlugins;\n\n    for (let [sort, plugin] of plugins) {\n      if (typeof plugin === 'function') {\n        for (let ruleSet of [].concat(plugin(modifier))) {\n          let [rules, options] = parseRules(ruleSet, context.postCssNodeCache);\n\n          for (let rule of rules) {\n            matches.push([{ ...sort,\n              options: { ...sort.options,\n                ...options\n              }\n            }, rule]);\n          }\n        }\n      } // Only process static plugins on exact matches\n      else if (modifier === 'DEFAULT') {\n        let ruleSet = plugin;\n        let [rules, options] = parseRules(ruleSet, context.postCssNodeCache);\n\n        for (let rule of rules) {\n          matches.push([{ ...sort,\n            options: { ...sort.options,\n              ...options\n            }\n          }, rule]);\n        }\n      }\n    }\n\n    matches = applyPrefix(matches, context);\n\n    if (important) {\n      matches = applyImportant(matches, context);\n    }\n\n    for (let variant of variants) {\n      matches = applyVariant(variant, matches, context);\n    }\n\n    for (let match of matches) {\n      yield match;\n    }\n  }\n}\n\nfunction inKeyframes(rule) {\n  return rule.parent && rule.parent.type === 'atrule' && rule.parent.name === 'keyframes';\n}\n\nfunction generateRules(candidates, context) {\n  let allRules = [];\n\n  for (let candidate of candidates) {\n    if (context.notClassCache.has(candidate)) {\n      continue;\n    }\n\n    if (context.classCache.has(candidate)) {\n      allRules.push(context.classCache.get(candidate));\n      continue;\n    }\n\n    let matches = Array.from(resolveMatches(candidate, context));\n\n    if (matches.length === 0) {\n      context.notClassCache.add(candidate);\n      continue;\n    }\n\n    context.classCache.set(candidate, matches);\n    allRules.push(matches);\n  }\n\n  return allRules.flat(1).map(([{\n    sort,\n    layer,\n    options\n  }, rule]) => {\n    if (options.respectImportant) {\n      if (context.tailwindConfig.important === true) {\n        rule.walkDecls(d => {\n          if (d.parent.type === 'rule' && !inKeyframes(d.parent)) {\n            d.important = true;\n          }\n        });\n      } else if (typeof context.tailwindConfig.important === 'string') {\n        let container = _postcss.default.root({\n          nodes: [rule.clone()]\n        });\n\n        container.walkRules(r => {\n          if (inKeyframes(r)) {\n            return;\n          }\n\n          r.selectors = r.selectors.map(selector => {\n            return `${context.tailwindConfig.important} ${selector}`;\n          });\n        });\n        rule = container.nodes[0];\n      }\n    }\n\n    return [sort | context.layerOrder[layer], rule];\n  });\n}"]},"metadata":{},"sourceType":"script"}