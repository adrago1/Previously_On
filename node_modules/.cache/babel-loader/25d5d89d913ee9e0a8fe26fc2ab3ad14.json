{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useMemo } from \"react\";\n\nconst range = (start, end) => {\n  let length = end - start + 1;\n  /* Tableau de taille non définie qui set les \n  elements à l'intérieur de la value de départ à \n  la valeur de fin\n  */\n\n  return Array.from({\n    length\n  }, (_, idx) => idx + start);\n};\n\nexport const usePagination = ({\n  totalCount,\n  pageSize,\n  siblingCount = 1,\n  currentPage\n}) => {\n  _s();\n\n  const paginationRange = useMemo(() => {\n    const totalPageCount = Math.ceil(totalCount / pageSize);\n    const totalPageNumbers = siblingCount + 5;\n    /* \n    Cas 1 :  Nombre de page inférieur au nombre \n    de pages qu'on veut afficher dans notre\n    Pagination, on return [1...totalpage]\n    */\n\n    if (totalPageNumbers >= totalPageCount) {\n      return range(1, totalPageCount);\n    } // Met à jour les pages côte a côte \n\n\n    const leftSiblingIndex = Math.max(currentPage - siblingCount, 1);\n    const rightSiblingIndex = Math.min(currentPage + siblingCount, totalPageCount); // Cacher les points quand il y a seulement une page\n\n    const shouldShowLeftDots = leftSiblingIndex > 2;\n    const shouldShowRightDots = rightSiblingIndex < totalPageCount - 2;\n    const firstPageIndex = 1;\n    const lastPageIndex = totalPageCount;\n    /*\n    Case 2: Pas de points à droite, mais points à gauche\n    */\n\n    if (!shouldShowLeftDots && shouldShowRightDots) {\n      let leftItemCount = 3 + 2 * siblingCount;\n      let leftRange = range(1, leftItemCount);\n      return [...leftRange, \"...\", totalPageCount];\n    }\n    /*\n    Cas 3: Inverse du cas 2\n    */\n\n\n    if (shouldShowLeftDots && !shouldShowRightDots) {\n      let rightItemCount = 3 + 2 * siblingCount;\n      let rightRange = range(totalPageCount - rightItemCount + 1, totalPageCount);\n      return [firstPageIndex, \"...\", ...rightRange];\n    }\n    /*\n    Cas 4: Montrer les points des deux côtés\n    */\n\n\n    if (shouldShowLeftDots && shouldShowRightDots) {\n      let middleRange = range(leftSiblingIndex, rightSiblingIndex);\n      return [firstPageIndex, \"...\", ...middleRange, \"...\", lastPageIndex];\n    }\n  }, [totalCount, pageSize, siblingCount, currentPage]);\n  return paginationRange;\n};\n\n_s(usePagination, \"tLviJI6rwkyze3+kNwkFLwjvB48=\");","map":{"version":3,"sources":["/home/gothelus/Previously_On/src/services/usePagination.js"],"names":["useMemo","range","start","end","length","Array","from","_","idx","usePagination","totalCount","pageSize","siblingCount","currentPage","paginationRange","totalPageCount","Math","ceil","totalPageNumbers","leftSiblingIndex","max","rightSiblingIndex","min","shouldShowLeftDots","shouldShowRightDots","firstPageIndex","lastPageIndex","leftItemCount","leftRange","rightItemCount","rightRange","middleRange"],"mappings":";;AAAA,SAASA,OAAT,QAAwB,OAAxB;;AAEA,MAAMC,KAAK,GAAG,CAACC,KAAD,EAAQC,GAAR,KAAgB;AAC1B,MAAIC,MAAM,GAAGD,GAAG,GAAGD,KAAN,GAAc,CAA3B;AACA;AACJ;AACA;AACA;;AAEI,SAAOG,KAAK,CAACC,IAAN,CAAW;AAAEF,IAAAA;AAAF,GAAX,EAAuB,CAACG,CAAD,EAAIC,GAAJ,KAAYA,GAAG,GAAGN,KAAzC,CAAP;AACH,CARD;;AAUA,OAAO,MAAMO,aAAa,GAAG,CAAC;AAC1BC,EAAAA,UAD0B;AAE1BC,EAAAA,QAF0B;AAG1BC,EAAAA,YAAY,GAAG,CAHW;AAI1BC,EAAAA;AAJ0B,CAAD,KAKvB;AAAA;;AACF,QAAMC,eAAe,GAAGd,OAAO,CAAC,MAAM;AAClC,UAAMe,cAAc,GAAGC,IAAI,CAACC,IAAL,CAAUP,UAAU,GAAIC,QAAxB,CAAvB;AAEA,UAAMO,gBAAgB,GAAGN,YAAY,GAAG,CAAxC;AAEA;AACR;AACA;AACA;AACA;;AACO,QAAIM,gBAAgB,IAAIH,cAAxB,EAAwC;AACpC,aAAOd,KAAK,CAAC,CAAD,EAAIc,cAAJ,CAAZ;AACH,KAZkC,CAanC;;;AACA,UAAMI,gBAAgB,GAAGH,IAAI,CAACI,GAAL,CAASP,WAAW,GAAGD,YAAvB,EAAqC,CAArC,CAAzB;AACA,UAAMS,iBAAiB,GAAGL,IAAI,CAACM,GAAL,CAAST,WAAW,GAAGD,YAAvB,EAAqCG,cAArC,CAA1B,CAfmC,CAiBnC;;AACA,UAAMQ,kBAAkB,GAAGJ,gBAAgB,GAAG,CAA9C;AACA,UAAMK,mBAAmB,GAAGH,iBAAiB,GAAGN,cAAc,GAAG,CAAjE;AAEA,UAAMU,cAAc,GAAG,CAAvB;AACA,UAAMC,aAAa,GAAGX,cAAtB;AAEC;AACR;AACA;;AACQ,QAAI,CAACQ,kBAAD,IAAuBC,mBAA3B,EAAgD;AAC5C,UAAIG,aAAa,GAAG,IAAI,IAAIf,YAA5B;AACA,UAAIgB,SAAS,GAAG3B,KAAK,CAAC,CAAD,EAAI0B,aAAJ,CAArB;AAEA,aAAO,CAAC,GAAGC,SAAJ,EAAe,KAAf,EAAsBb,cAAtB,CAAP;AACH;AAED;AACR;AACA;;;AACQ,QAAIQ,kBAAkB,IAAI,CAACC,mBAA3B,EAAgD;AAC5C,UAAIK,cAAc,GAAG,IAAI,IAAIjB,YAA7B;AACA,UAAIkB,UAAU,GAAG7B,KAAK,CAClBc,cAAc,GAAGc,cAAjB,GAAkC,CADhB,EACmBd,cADnB,CAAtB;AAGA,aAAO,CAACU,cAAD,EAAiB,KAAjB,EAAwB,GAAGK,UAA3B,CAAP;AACH;AAED;AACR;AACA;;;AACO,QAAIP,kBAAkB,IAAIC,mBAA1B,EAA+C;AAC3C,UAAIO,WAAW,GAAG9B,KAAK,CAACkB,gBAAD,EAAmBE,iBAAnB,CAAvB;AACA,aAAO,CAACI,cAAD,EAAiB,KAAjB,EAAwB,GAAGM,WAA3B,EAAwC,KAAxC,EAA+CL,aAA/C,CAAP;AACH;AAEH,GArD8B,EAqD5B,CAAChB,UAAD,EAAaC,QAAb,EAAuBC,YAAvB,EAAqCC,WAArC,CArD4B,CAA/B;AAuDA,SAAOC,eAAP;AACH,CA9DM;;GAAML,a","sourcesContent":["import { useMemo } from \"react\";\n\nconst range = (start, end) => {\n    let length = end - start + 1;\n    /* Tableau de taille non définie qui set les \n    elements à l'intérieur de la value de départ à \n    la valeur de fin\n    */\n\n    return Array.from({ length }, (_, idx) => idx + start);\n}\n\nexport const usePagination = ({\n    totalCount,\n    pageSize,\n    siblingCount = 1,\n    currentPage\n}) => {\n    const paginationRange = useMemo(() => {\n        const totalPageCount = Math.ceil(totalCount /  pageSize);\n\n        const totalPageNumbers = siblingCount + 5;\n\n        /* \n        Cas 1 :  Nombre de page inférieur au nombre \n        de pages qu'on veut afficher dans notre\n        Pagination, on return [1...totalpage]\n        */\n       if (totalPageNumbers >= totalPageCount) {\n           return range(1, totalPageCount);\n       }\n       // Met à jour les pages côte a côte \n       const leftSiblingIndex = Math.max(currentPage - siblingCount, 1);\n       const rightSiblingIndex = Math.min(currentPage + siblingCount, totalPageCount);\n\n       // Cacher les points quand il y a seulement une page\n       const shouldShowLeftDots = leftSiblingIndex > 2;\n       const shouldShowRightDots = rightSiblingIndex < totalPageCount - 2;\n\n       const firstPageIndex = 1;\n       const lastPageIndex = totalPageCount;\n\n        /*\n        Case 2: Pas de points à droite, mais points à gauche\n        */\n        if (!shouldShowLeftDots && shouldShowRightDots) {\n            let leftItemCount = 3 + 2 * siblingCount;\n            let leftRange = range(1, leftItemCount);\n\n            return [...leftRange, \"...\", totalPageCount];\n        }\n\n        /*\n        Cas 3: Inverse du cas 2\n        */\n        if (shouldShowLeftDots && !shouldShowRightDots) {\n            let rightItemCount = 3 + 2 * siblingCount;\n            let rightRange = range(\n                totalPageCount - rightItemCount + 1, totalPageCount\n            );\n            return [firstPageIndex, \"...\", ...rightRange];\n        }\n\n        /*\n        Cas 4: Montrer les points des deux côtés\n        */\n       if (shouldShowLeftDots && shouldShowRightDots) {\n           let middleRange = range(leftSiblingIndex, rightSiblingIndex);\n           return [firstPageIndex, \"...\", ...middleRange, \"...\", lastPageIndex];\n       }\n\n    }, [totalCount, pageSize, siblingCount, currentPage]);\n\n    return paginationRange;\n}"]},"metadata":{},"sourceType":"module"}