{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.matchAny = exports.convertPatternsToRe = exports.makeRe = exports.getPatternParts = exports.expandBraceExpansion = exports.expandPatternsWithBraceExpansion = exports.isAffectDepthOfReadingPattern = exports.endsWithSlashGlobStar = exports.hasGlobStar = exports.getBaseDirectory = exports.isPatternRelatedToParentDirectory = exports.getPatternsOutsideCurrentDirectory = exports.getPatternsInsideCurrentDirectory = exports.getPositivePatterns = exports.getNegativePatterns = exports.isPositivePattern = exports.isNegativePattern = exports.convertToNegativePattern = exports.convertToPositivePattern = exports.isDynamicPattern = exports.isStaticPattern = void 0;\n\nconst path = require(\"path\");\n\nconst globParent = require(\"glob-parent\");\n\nconst micromatch = require(\"micromatch\");\n\nconst GLOBSTAR = '**';\nconst ESCAPE_SYMBOL = '\\\\';\nconst COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;\nconst REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\\[.*]/;\nconst REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\\(.*\\|.*\\)/;\nconst GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\\(.*\\)/;\nconst BRACE_EXPANSIONS_SYMBOLS_RE = /{.*(?:,|\\.\\.).*}/;\n\nfunction isStaticPattern(pattern, options = {}) {\n  return !isDynamicPattern(pattern, options);\n}\n\nexports.isStaticPattern = isStaticPattern;\n\nfunction isDynamicPattern(pattern, options = {}) {\n  /**\n   * A special case with an empty string is necessary for matching patterns that start with a forward slash.\n   * An empty string cannot be a dynamic pattern.\n   * For example, the pattern `/lib/*` will be spread into parts: '', 'lib', '*'.\n   */\n  if (pattern === '') {\n    return false;\n  }\n  /**\n   * When the `caseSensitiveMatch` option is disabled, all patterns must be marked as dynamic, because we cannot check\n   * filepath directly (without read directory).\n   */\n\n\n  if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {\n    return true;\n  }\n\n  if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {\n    return true;\n  }\n\n  if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {\n    return true;\n  }\n\n  if (options.braceExpansion !== false && BRACE_EXPANSIONS_SYMBOLS_RE.test(pattern)) {\n    return true;\n  }\n\n  return false;\n}\n\nexports.isDynamicPattern = isDynamicPattern;\n\nfunction convertToPositivePattern(pattern) {\n  return isNegativePattern(pattern) ? pattern.slice(1) : pattern;\n}\n\nexports.convertToPositivePattern = convertToPositivePattern;\n\nfunction convertToNegativePattern(pattern) {\n  return '!' + pattern;\n}\n\nexports.convertToNegativePattern = convertToNegativePattern;\n\nfunction isNegativePattern(pattern) {\n  return pattern.startsWith('!') && pattern[1] !== '(';\n}\n\nexports.isNegativePattern = isNegativePattern;\n\nfunction isPositivePattern(pattern) {\n  return !isNegativePattern(pattern);\n}\n\nexports.isPositivePattern = isPositivePattern;\n\nfunction getNegativePatterns(patterns) {\n  return patterns.filter(isNegativePattern);\n}\n\nexports.getNegativePatterns = getNegativePatterns;\n\nfunction getPositivePatterns(patterns) {\n  return patterns.filter(isPositivePattern);\n}\n\nexports.getPositivePatterns = getPositivePatterns;\n/**\n * Returns patterns that can be applied inside the current directory.\n *\n * @example\n * // ['./*', '*', 'a/*']\n * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])\n */\n\nfunction getPatternsInsideCurrentDirectory(patterns) {\n  return patterns.filter(pattern => !isPatternRelatedToParentDirectory(pattern));\n}\n\nexports.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;\n/**\n * Returns patterns to be expanded relative to (outside) the current directory.\n *\n * @example\n * // ['../*', './../*']\n * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])\n */\n\nfunction getPatternsOutsideCurrentDirectory(patterns) {\n  return patterns.filter(isPatternRelatedToParentDirectory);\n}\n\nexports.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;\n\nfunction isPatternRelatedToParentDirectory(pattern) {\n  return pattern.startsWith('..') || pattern.startsWith('./..');\n}\n\nexports.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;\n\nfunction getBaseDirectory(pattern) {\n  return globParent(pattern, {\n    flipBackslashes: false\n  });\n}\n\nexports.getBaseDirectory = getBaseDirectory;\n\nfunction hasGlobStar(pattern) {\n  return pattern.includes(GLOBSTAR);\n}\n\nexports.hasGlobStar = hasGlobStar;\n\nfunction endsWithSlashGlobStar(pattern) {\n  return pattern.endsWith('/' + GLOBSTAR);\n}\n\nexports.endsWithSlashGlobStar = endsWithSlashGlobStar;\n\nfunction isAffectDepthOfReadingPattern(pattern) {\n  const basename = path.basename(pattern);\n  return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);\n}\n\nexports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;\n\nfunction expandPatternsWithBraceExpansion(patterns) {\n  return patterns.reduce((collection, pattern) => {\n    return collection.concat(expandBraceExpansion(pattern));\n  }, []);\n}\n\nexports.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;\n\nfunction expandBraceExpansion(pattern) {\n  return micromatch.braces(pattern, {\n    expand: true,\n    nodupes: true\n  });\n}\n\nexports.expandBraceExpansion = expandBraceExpansion;\n\nfunction getPatternParts(pattern, options) {\n  let {\n    parts\n  } = micromatch.scan(pattern, Object.assign(Object.assign({}, options), {\n    parts: true\n  }));\n  /**\n   * The scan method returns an empty array in some cases.\n   * See micromatch/picomatch#58 for more details.\n   */\n\n  if (parts.length === 0) {\n    parts = [pattern];\n  }\n  /**\n   * The scan method does not return an empty part for the pattern with a forward slash.\n   * This is another part of micromatch/picomatch#58.\n   */\n\n\n  if (parts[0].startsWith('/')) {\n    parts[0] = parts[0].slice(1);\n    parts.unshift('');\n  }\n\n  return parts;\n}\n\nexports.getPatternParts = getPatternParts;\n\nfunction makeRe(pattern, options) {\n  return micromatch.makeRe(pattern, options);\n}\n\nexports.makeRe = makeRe;\n\nfunction convertPatternsToRe(patterns, options) {\n  return patterns.map(pattern => makeRe(pattern, options));\n}\n\nexports.convertPatternsToRe = convertPatternsToRe;\n\nfunction matchAny(entry, patternsRe) {\n  return patternsRe.some(patternRe => patternRe.test(entry));\n}\n\nexports.matchAny = matchAny;","map":{"version":3,"sources":["/home/alan/delivery_2/previously_on/client/node_modules/fast-glob/out/utils/pattern.js"],"names":["Object","defineProperty","exports","value","matchAny","convertPatternsToRe","makeRe","getPatternParts","expandBraceExpansion","expandPatternsWithBraceExpansion","isAffectDepthOfReadingPattern","endsWithSlashGlobStar","hasGlobStar","getBaseDirectory","isPatternRelatedToParentDirectory","getPatternsOutsideCurrentDirectory","getPatternsInsideCurrentDirectory","getPositivePatterns","getNegativePatterns","isPositivePattern","isNegativePattern","convertToNegativePattern","convertToPositivePattern","isDynamicPattern","isStaticPattern","path","require","globParent","micromatch","GLOBSTAR","ESCAPE_SYMBOL","COMMON_GLOB_SYMBOLS_RE","REGEX_CHARACTER_CLASS_SYMBOLS_RE","REGEX_GROUP_SYMBOLS_RE","GLOB_EXTENSION_SYMBOLS_RE","BRACE_EXPANSIONS_SYMBOLS_RE","pattern","options","caseSensitiveMatch","includes","test","extglob","braceExpansion","slice","startsWith","patterns","filter","flipBackslashes","endsWith","basename","reduce","collection","concat","braces","expand","nodupes","parts","scan","assign","length","unshift","map","entry","patternsRe","some","patternRe"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.matchAny = exports.convertPatternsToRe = exports.makeRe = exports.getPatternParts = exports.expandBraceExpansion = exports.expandPatternsWithBraceExpansion = exports.isAffectDepthOfReadingPattern = exports.endsWithSlashGlobStar = exports.hasGlobStar = exports.getBaseDirectory = exports.isPatternRelatedToParentDirectory = exports.getPatternsOutsideCurrentDirectory = exports.getPatternsInsideCurrentDirectory = exports.getPositivePatterns = exports.getNegativePatterns = exports.isPositivePattern = exports.isNegativePattern = exports.convertToNegativePattern = exports.convertToPositivePattern = exports.isDynamicPattern = exports.isStaticPattern = void 0;\nconst path = require(\"path\");\nconst globParent = require(\"glob-parent\");\nconst micromatch = require(\"micromatch\");\nconst GLOBSTAR = '**';\nconst ESCAPE_SYMBOL = '\\\\';\nconst COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;\nconst REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\\[.*]/;\nconst REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\\(.*\\|.*\\)/;\nconst GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\\(.*\\)/;\nconst BRACE_EXPANSIONS_SYMBOLS_RE = /{.*(?:,|\\.\\.).*}/;\nfunction isStaticPattern(pattern, options = {}) {\n    return !isDynamicPattern(pattern, options);\n}\nexports.isStaticPattern = isStaticPattern;\nfunction isDynamicPattern(pattern, options = {}) {\n    /**\n     * A special case with an empty string is necessary for matching patterns that start with a forward slash.\n     * An empty string cannot be a dynamic pattern.\n     * For example, the pattern `/lib/*` will be spread into parts: '', 'lib', '*'.\n     */\n    if (pattern === '') {\n        return false;\n    }\n    /**\n     * When the `caseSensitiveMatch` option is disabled, all patterns must be marked as dynamic, because we cannot check\n     * filepath directly (without read directory).\n     */\n    if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {\n        return true;\n    }\n    if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {\n        return true;\n    }\n    if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {\n        return true;\n    }\n    if (options.braceExpansion !== false && BRACE_EXPANSIONS_SYMBOLS_RE.test(pattern)) {\n        return true;\n    }\n    return false;\n}\nexports.isDynamicPattern = isDynamicPattern;\nfunction convertToPositivePattern(pattern) {\n    return isNegativePattern(pattern) ? pattern.slice(1) : pattern;\n}\nexports.convertToPositivePattern = convertToPositivePattern;\nfunction convertToNegativePattern(pattern) {\n    return '!' + pattern;\n}\nexports.convertToNegativePattern = convertToNegativePattern;\nfunction isNegativePattern(pattern) {\n    return pattern.startsWith('!') && pattern[1] !== '(';\n}\nexports.isNegativePattern = isNegativePattern;\nfunction isPositivePattern(pattern) {\n    return !isNegativePattern(pattern);\n}\nexports.isPositivePattern = isPositivePattern;\nfunction getNegativePatterns(patterns) {\n    return patterns.filter(isNegativePattern);\n}\nexports.getNegativePatterns = getNegativePatterns;\nfunction getPositivePatterns(patterns) {\n    return patterns.filter(isPositivePattern);\n}\nexports.getPositivePatterns = getPositivePatterns;\n/**\n * Returns patterns that can be applied inside the current directory.\n *\n * @example\n * // ['./*', '*', 'a/*']\n * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])\n */\nfunction getPatternsInsideCurrentDirectory(patterns) {\n    return patterns.filter((pattern) => !isPatternRelatedToParentDirectory(pattern));\n}\nexports.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;\n/**\n * Returns patterns to be expanded relative to (outside) the current directory.\n *\n * @example\n * // ['../*', './../*']\n * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])\n */\nfunction getPatternsOutsideCurrentDirectory(patterns) {\n    return patterns.filter(isPatternRelatedToParentDirectory);\n}\nexports.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;\nfunction isPatternRelatedToParentDirectory(pattern) {\n    return pattern.startsWith('..') || pattern.startsWith('./..');\n}\nexports.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;\nfunction getBaseDirectory(pattern) {\n    return globParent(pattern, { flipBackslashes: false });\n}\nexports.getBaseDirectory = getBaseDirectory;\nfunction hasGlobStar(pattern) {\n    return pattern.includes(GLOBSTAR);\n}\nexports.hasGlobStar = hasGlobStar;\nfunction endsWithSlashGlobStar(pattern) {\n    return pattern.endsWith('/' + GLOBSTAR);\n}\nexports.endsWithSlashGlobStar = endsWithSlashGlobStar;\nfunction isAffectDepthOfReadingPattern(pattern) {\n    const basename = path.basename(pattern);\n    return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);\n}\nexports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;\nfunction expandPatternsWithBraceExpansion(patterns) {\n    return patterns.reduce((collection, pattern) => {\n        return collection.concat(expandBraceExpansion(pattern));\n    }, []);\n}\nexports.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;\nfunction expandBraceExpansion(pattern) {\n    return micromatch.braces(pattern, {\n        expand: true,\n        nodupes: true\n    });\n}\nexports.expandBraceExpansion = expandBraceExpansion;\nfunction getPatternParts(pattern, options) {\n    let { parts } = micromatch.scan(pattern, Object.assign(Object.assign({}, options), { parts: true }));\n    /**\n     * The scan method returns an empty array in some cases.\n     * See micromatch/picomatch#58 for more details.\n     */\n    if (parts.length === 0) {\n        parts = [pattern];\n    }\n    /**\n     * The scan method does not return an empty part for the pattern with a forward slash.\n     * This is another part of micromatch/picomatch#58.\n     */\n    if (parts[0].startsWith('/')) {\n        parts[0] = parts[0].slice(1);\n        parts.unshift('');\n    }\n    return parts;\n}\nexports.getPatternParts = getPatternParts;\nfunction makeRe(pattern, options) {\n    return micromatch.makeRe(pattern, options);\n}\nexports.makeRe = makeRe;\nfunction convertPatternsToRe(patterns, options) {\n    return patterns.map((pattern) => makeRe(pattern, options));\n}\nexports.convertPatternsToRe = convertPatternsToRe;\nfunction matchAny(entry, patternsRe) {\n    return patternsRe.some((patternRe) => patternRe.test(entry));\n}\nexports.matchAny = matchAny;\n"]},"metadata":{},"sourceType":"script"}