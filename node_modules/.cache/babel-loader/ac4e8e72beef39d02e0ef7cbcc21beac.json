{"ast":null,"code":"/*!\n * Tmp\n *\n * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>\n *\n * MIT Licensed\n */\n\n/*\n * Module dependencies.\n */\nconst fs = require('fs');\n\nconst os = require('os');\n\nconst path = require('path');\n\nconst crypto = require('crypto');\n\nconst _c = {\n  fs: fs.constants,\n  os: os.constants\n};\n\nconst rimraf = require('rimraf');\n/*\n * The working inner variables.\n */\n\n\nconst // the random characters to choose from\nRANDOM_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n      TEMPLATE_PATTERN = /XXXXXX/,\n      DEFAULT_TRIES = 3,\n      CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR),\n      // constants are off on the windows platform and will not match the actual errno codes\nIS_WIN32 = os.platform() === 'win32',\n      EBADF = _c.EBADF || _c.os.errno.EBADF,\n      ENOENT = _c.ENOENT || _c.os.errno.ENOENT,\n      DIR_MODE = 0o700\n/* 448 */\n,\n      FILE_MODE = 0o600\n/* 384 */\n,\n      EXIT = 'exit',\n      // this will hold the objects need to be removed on exit\n_removeObjects = [],\n      // API change in fs.rmdirSync leads to error when passing in a second parameter, e.g. the callback\nFN_RMDIR_SYNC = fs.rmdirSync.bind(fs),\n      FN_RIMRAF_SYNC = rimraf.sync;\nlet _gracefulCleanup = false;\n/**\n * Gets a temporary file name.\n *\n * @param {(Options|tmpNameCallback)} options options or callback\n * @param {?tmpNameCallback} callback the callback function\n */\n\nfunction tmpName(options, callback) {\n  const args = _parseArguments(options, callback),\n        opts = args[0],\n        cb = args[1];\n\n  try {\n    _assertAndSanitizeOptions(opts);\n  } catch (err) {\n    return cb(err);\n  }\n\n  let tries = opts.tries;\n\n  (function _getUniqueName() {\n    try {\n      const name = _generateTmpName(opts); // check whether the path exists then retry if needed\n\n\n      fs.stat(name, function (err) {\n        /* istanbul ignore else */\n        if (!err) {\n          /* istanbul ignore else */\n          if (tries-- > 0) return _getUniqueName();\n          return cb(new Error('Could not get a unique tmp filename, max tries reached ' + name));\n        }\n\n        cb(null, name);\n      });\n    } catch (err) {\n      cb(err);\n    }\n  })();\n}\n/**\n * Synchronous version of tmpName.\n *\n * @param {Object} options\n * @returns {string} the generated random name\n * @throws {Error} if the options are invalid or could not generate a filename\n */\n\n\nfunction tmpNameSync(options) {\n  const args = _parseArguments(options),\n        opts = args[0];\n\n  _assertAndSanitizeOptions(opts);\n\n  let tries = opts.tries;\n\n  do {\n    const name = _generateTmpName(opts);\n\n    try {\n      fs.statSync(name);\n    } catch (e) {\n      return name;\n    }\n  } while (tries-- > 0);\n\n  throw new Error('Could not get a unique tmp filename, max tries reached');\n}\n/**\n * Creates and opens a temporary file.\n *\n * @param {(Options|null|undefined|fileCallback)} options the config options or the callback function or null or undefined\n * @param {?fileCallback} callback\n */\n\n\nfunction file(options, callback) {\n  const args = _parseArguments(options, callback),\n        opts = args[0],\n        cb = args[1]; // gets a temporary filename\n\n\n  tmpName(opts, function _tmpNameCreated(err, name) {\n    /* istanbul ignore else */\n    if (err) return cb(err); // create and open the file\n\n    fs.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err, fd) {\n      /* istanbu ignore else */\n      if (err) return cb(err);\n\n      if (opts.discardDescriptor) {\n        return fs.close(fd, function _discardCallback(possibleErr) {\n          // the chance of getting an error on close here is rather low and might occur in the most edgiest cases only\n          return cb(possibleErr, name, undefined, _prepareTmpFileRemoveCallback(name, -1, opts, false));\n        });\n      } else {\n        // detachDescriptor passes the descriptor whereas discardDescriptor closes it, either way, we no longer care\n        // about the descriptor\n        const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;\n        cb(null, name, fd, _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, false));\n      }\n    });\n  });\n}\n/**\n * Synchronous version of file.\n *\n * @param {Options} options\n * @returns {FileSyncObject} object consists of name, fd and removeCallback\n * @throws {Error} if cannot create a file\n */\n\n\nfunction fileSync(options) {\n  const args = _parseArguments(options),\n        opts = args[0];\n\n  const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;\n  const name = tmpNameSync(opts);\n  var fd = fs.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);\n  /* istanbul ignore else */\n\n  if (opts.discardDescriptor) {\n    fs.closeSync(fd);\n    fd = undefined;\n  }\n\n  return {\n    name: name,\n    fd: fd,\n    removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, true)\n  };\n}\n/**\n * Creates a temporary directory.\n *\n * @param {(Options|dirCallback)} options the options or the callback function\n * @param {?dirCallback} callback\n */\n\n\nfunction dir(options, callback) {\n  const args = _parseArguments(options, callback),\n        opts = args[0],\n        cb = args[1]; // gets a temporary filename\n\n\n  tmpName(opts, function _tmpNameCreated(err, name) {\n    /* istanbul ignore else */\n    if (err) return cb(err); // create the directory\n\n    fs.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err) {\n      /* istanbul ignore else */\n      if (err) return cb(err);\n      cb(null, name, _prepareTmpDirRemoveCallback(name, opts, false));\n    });\n  });\n}\n/**\n * Synchronous version of dir.\n *\n * @param {Options} options\n * @returns {DirSyncObject} object consists of name and removeCallback\n * @throws {Error} if it cannot create a directory\n */\n\n\nfunction dirSync(options) {\n  const args = _parseArguments(options),\n        opts = args[0];\n\n  const name = tmpNameSync(opts);\n  fs.mkdirSync(name, opts.mode || DIR_MODE);\n  return {\n    name: name,\n    removeCallback: _prepareTmpDirRemoveCallback(name, opts, true)\n  };\n}\n/**\n * Removes files asynchronously.\n *\n * @param {Object} fdPath\n * @param {Function} next\n * @private\n */\n\n\nfunction _removeFileAsync(fdPath, next) {\n  const _handler = function (err) {\n    if (err && !_isENOENT(err)) {\n      // reraise any unanticipated error\n      return next(err);\n    }\n\n    next();\n  };\n\n  if (0 <= fdPath[0]) fs.close(fdPath[0], function () {\n    fs.unlink(fdPath[1], _handler);\n  });else fs.unlink(fdPath[1], _handler);\n}\n/**\n * Removes files synchronously.\n *\n * @param {Object} fdPath\n * @private\n */\n\n\nfunction _removeFileSync(fdPath) {\n  let rethrownException = null;\n\n  try {\n    if (0 <= fdPath[0]) fs.closeSync(fdPath[0]);\n  } catch (e) {\n    // reraise any unanticipated error\n    if (!_isEBADF(e) && !_isENOENT(e)) throw e;\n  } finally {\n    try {\n      fs.unlinkSync(fdPath[1]);\n    } catch (e) {\n      // reraise any unanticipated error\n      if (!_isENOENT(e)) rethrownException = e;\n    }\n  }\n\n  if (rethrownException !== null) {\n    throw rethrownException;\n  }\n}\n/**\n * Prepares the callback for removal of the temporary file.\n *\n * Returns either a sync callback or a async callback depending on whether\n * fileSync or file was called, which is expressed by the sync parameter.\n *\n * @param {string} name the path of the file\n * @param {number} fd file descriptor\n * @param {Object} opts\n * @param {boolean} sync\n * @returns {fileCallback | fileCallbackSync}\n * @private\n */\n\n\nfunction _prepareTmpFileRemoveCallback(name, fd, opts, sync) {\n  const removeCallbackSync = _prepareRemoveCallback(_removeFileSync, [fd, name], sync);\n\n  const removeCallback = _prepareRemoveCallback(_removeFileAsync, [fd, name], sync, removeCallbackSync);\n\n  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);\n  return sync ? removeCallbackSync : removeCallback;\n}\n/**\n * Prepares the callback for removal of the temporary directory.\n *\n * Returns either a sync callback or a async callback depending on whether\n * tmpFileSync or tmpFile was called, which is expressed by the sync parameter.\n *\n * @param {string} name\n * @param {Object} opts\n * @param {boolean} sync\n * @returns {Function} the callback\n * @private\n */\n\n\nfunction _prepareTmpDirRemoveCallback(name, opts, sync) {\n  const removeFunction = opts.unsafeCleanup ? rimraf : fs.rmdir.bind(fs);\n  const removeFunctionSync = opts.unsafeCleanup ? FN_RIMRAF_SYNC : FN_RMDIR_SYNC;\n\n  const removeCallbackSync = _prepareRemoveCallback(removeFunctionSync, name, sync);\n\n  const removeCallback = _prepareRemoveCallback(removeFunction, name, sync, removeCallbackSync);\n\n  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);\n  return sync ? removeCallbackSync : removeCallback;\n}\n/**\n * Creates a guarded function wrapping the removeFunction call.\n *\n * The cleanup callback is save to be called multiple times.\n * Subsequent invocations will be ignored.\n *\n * @param {Function} removeFunction\n * @param {string} fileOrDirName\n * @param {boolean} sync\n * @param {cleanupCallbackSync?} cleanupCallbackSync\n * @returns {cleanupCallback | cleanupCallbackSync}\n * @private\n */\n\n\nfunction _prepareRemoveCallback(removeFunction, fileOrDirName, sync, cleanupCallbackSync) {\n  let called = false; // if sync is true, the next parameter will be ignored\n\n  return function _cleanupCallback(next) {\n    /* istanbul ignore else */\n    if (!called) {\n      // remove cleanupCallback from cache\n      const toRemove = cleanupCallbackSync || _cleanupCallback;\n\n      const index = _removeObjects.indexOf(toRemove);\n      /* istanbul ignore else */\n\n\n      if (index >= 0) _removeObjects.splice(index, 1);\n      called = true;\n\n      if (sync || removeFunction === FN_RMDIR_SYNC || removeFunction === FN_RIMRAF_SYNC) {\n        return removeFunction(fileOrDirName);\n      } else {\n        return removeFunction(fileOrDirName, next || function () {});\n      }\n    }\n  };\n}\n/**\n * The garbage collector.\n *\n * @private\n */\n\n\nfunction _garbageCollector() {\n  /* istanbul ignore else */\n  if (!_gracefulCleanup) return; // the function being called removes itself from _removeObjects,\n  // loop until _removeObjects is empty\n\n  while (_removeObjects.length) {\n    try {\n      _removeObjects[0]();\n    } catch (e) {// already removed?\n    }\n  }\n}\n/**\n * Random name generator based on crypto.\n * Adapted from http://blog.tompawlak.org/how-to-generate-random-values-nodejs-javascript\n *\n * @param {number} howMany\n * @returns {string} the generated random name\n * @private\n */\n\n\nfunction _randomChars(howMany) {\n  let value = [],\n      rnd = null; // make sure that we do not fail because we ran out of entropy\n\n  try {\n    rnd = crypto.randomBytes(howMany);\n  } catch (e) {\n    rnd = crypto.pseudoRandomBytes(howMany);\n  }\n\n  for (var i = 0; i < howMany; i++) {\n    value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);\n  }\n\n  return value.join('');\n}\n/**\n * Helper which determines whether a string s is blank, that is undefined, or empty or null.\n *\n * @private\n * @param {string} s\n * @returns {Boolean} true whether the string s is blank, false otherwise\n */\n\n\nfunction _isBlank(s) {\n  return s === null || _isUndefined(s) || !s.trim();\n}\n/**\n * Checks whether the `obj` parameter is defined or not.\n *\n * @param {Object} obj\n * @returns {boolean} true if the object is undefined\n * @private\n */\n\n\nfunction _isUndefined(obj) {\n  return typeof obj === 'undefined';\n}\n/**\n * Parses the function arguments.\n *\n * This function helps to have optional arguments.\n *\n * @param {(Options|null|undefined|Function)} options\n * @param {?Function} callback\n * @returns {Array} parsed arguments\n * @private\n */\n\n\nfunction _parseArguments(options, callback) {\n  /* istanbul ignore else */\n  if (typeof options === 'function') {\n    return [{}, options];\n  }\n  /* istanbul ignore else */\n\n\n  if (_isUndefined(options)) {\n    return [{}, callback];\n  } // copy options so we do not leak the changes we make internally\n\n\n  const actualOptions = {};\n\n  for (const key of Object.getOwnPropertyNames(options)) {\n    actualOptions[key] = options[key];\n  }\n\n  return [actualOptions, callback];\n}\n/**\n * Generates a new temporary name.\n *\n * @param {Object} opts\n * @returns {string} the new random name according to opts\n * @private\n */\n\n\nfunction _generateTmpName(opts) {\n  const tmpDir = opts.tmpdir;\n  /* istanbul ignore else */\n\n  if (!_isUndefined(opts.name)) return path.join(tmpDir, opts.dir, opts.name);\n  /* istanbul ignore else */\n\n  if (!_isUndefined(opts.template)) return path.join(tmpDir, opts.dir, opts.template).replace(TEMPLATE_PATTERN, _randomChars(6)); // prefix and postfix\n\n  const name = [opts.prefix ? opts.prefix : 'tmp', '-', process.pid, '-', _randomChars(12), opts.postfix ? '-' + opts.postfix : ''].join('');\n  return path.join(tmpDir, opts.dir, name);\n}\n/**\n * Asserts whether the specified options are valid, also sanitizes options and provides sane defaults for missing\n * options.\n *\n * @param {Options} options\n * @private\n */\n\n\nfunction _assertAndSanitizeOptions(options) {\n  options.tmpdir = _getTmpDir(options);\n  const tmpDir = options.tmpdir;\n  /* istanbul ignore else */\n\n  if (!_isUndefined(options.name)) _assertIsRelative(options.name, 'name', tmpDir);\n  /* istanbul ignore else */\n\n  if (!_isUndefined(options.dir)) _assertIsRelative(options.dir, 'dir', tmpDir);\n  /* istanbul ignore else */\n\n  if (!_isUndefined(options.template)) {\n    _assertIsRelative(options.template, 'template', tmpDir);\n\n    if (!options.template.match(TEMPLATE_PATTERN)) throw new Error(`Invalid template, found \"${options.template}\".`);\n  }\n  /* istanbul ignore else */\n\n\n  if (!_isUndefined(options.tries) && isNaN(options.tries) || options.tries < 0) throw new Error(`Invalid tries, found \"${options.tries}\".`); // if a name was specified we will try once\n\n  options.tries = _isUndefined(options.name) ? options.tries || DEFAULT_TRIES : 1;\n  options.keep = !!options.keep;\n  options.detachDescriptor = !!options.detachDescriptor;\n  options.discardDescriptor = !!options.discardDescriptor;\n  options.unsafeCleanup = !!options.unsafeCleanup; // sanitize dir, also keep (multiple) blanks if the user, purportedly sane, requests us to\n\n  options.dir = _isUndefined(options.dir) ? '' : path.relative(tmpDir, _resolvePath(options.dir, tmpDir));\n  options.template = _isUndefined(options.template) ? undefined : path.relative(tmpDir, _resolvePath(options.template, tmpDir)); // sanitize further if template is relative to options.dir\n\n  options.template = _isBlank(options.template) ? undefined : path.relative(options.dir, options.template); // for completeness' sake only, also keep (multiple) blanks if the user, purportedly sane, requests us to\n\n  options.name = _isUndefined(options.name) ? undefined : _sanitizeName(options.name);\n  options.prefix = _isUndefined(options.prefix) ? '' : options.prefix;\n  options.postfix = _isUndefined(options.postfix) ? '' : options.postfix;\n}\n/**\n * Resolve the specified path name in respect to tmpDir.\n *\n * The specified name might include relative path components, e.g. ../\n * so we need to resolve in order to be sure that is is located inside tmpDir\n *\n * @param name\n * @param tmpDir\n * @returns {string}\n * @private\n */\n\n\nfunction _resolvePath(name, tmpDir) {\n  const sanitizedName = _sanitizeName(name);\n\n  if (sanitizedName.startsWith(tmpDir)) {\n    return path.resolve(sanitizedName);\n  } else {\n    return path.resolve(path.join(tmpDir, sanitizedName));\n  }\n}\n/**\n * Sanitize the specified path name by removing all quote characters.\n *\n * @param name\n * @returns {string}\n * @private\n */\n\n\nfunction _sanitizeName(name) {\n  if (_isBlank(name)) {\n    return name;\n  }\n\n  return name.replace(/[\"']/g, '');\n}\n/**\n * Asserts whether specified name is relative to the specified tmpDir.\n *\n * @param {string} name\n * @param {string} option\n * @param {string} tmpDir\n * @throws {Error}\n * @private\n */\n\n\nfunction _assertIsRelative(name, option, tmpDir) {\n  if (option === 'name') {\n    // assert that name is not absolute and does not contain a path\n    if (path.isAbsolute(name)) throw new Error(`${option} option must not contain an absolute path, found \"${name}\".`); // must not fail on valid .<name> or ..<name> or similar such constructs\n\n    let basename = path.basename(name);\n    if (basename === '..' || basename === '.' || basename !== name) throw new Error(`${option} option must not contain a path, found \"${name}\".`);\n  } else {\n    // if (option === 'dir' || option === 'template') {\n    // assert that dir or template are relative to tmpDir\n    if (path.isAbsolute(name) && !name.startsWith(tmpDir)) {\n      throw new Error(`${option} option must be relative to \"${tmpDir}\", found \"${name}\".`);\n    }\n\n    let resolvedPath = _resolvePath(name, tmpDir);\n\n    if (!resolvedPath.startsWith(tmpDir)) throw new Error(`${option} option must be relative to \"${tmpDir}\", found \"${resolvedPath}\".`);\n  }\n}\n/**\n * Helper for testing against EBADF to compensate changes made to Node 7.x under Windows.\n *\n * @private\n */\n\n\nfunction _isEBADF(error) {\n  return _isExpectedError(error, -EBADF, 'EBADF');\n}\n/**\n * Helper for testing against ENOENT to compensate changes made to Node 7.x under Windows.\n *\n * @private\n */\n\n\nfunction _isENOENT(error) {\n  return _isExpectedError(error, -ENOENT, 'ENOENT');\n}\n/**\n * Helper to determine whether the expected error code matches the actual code and errno,\n * which will differ between the supported node versions.\n *\n * - Node >= 7.0:\n *   error.code {string}\n *   error.errno {number} any numerical value will be negated\n *\n * CAVEAT\n *\n * On windows, the errno for EBADF is -4083 but os.constants.errno.EBADF is different and we must assume that ENOENT\n * is no different here.\n *\n * @param {SystemError} error\n * @param {number} errno\n * @param {string} code\n * @private\n */\n\n\nfunction _isExpectedError(error, errno, code) {\n  return IS_WIN32 ? error.code === code : error.code === code && error.errno === errno;\n}\n/**\n * Sets the graceful cleanup.\n *\n * If graceful cleanup is set, tmp will remove all controlled temporary objects on process exit, otherwise the\n * temporary objects will remain in place, waiting to be cleaned up on system restart or otherwise scheduled temporary\n * object removals.\n */\n\n\nfunction setGracefulCleanup() {\n  _gracefulCleanup = true;\n}\n/**\n * Returns the currently configured tmp dir from os.tmpdir().\n *\n * @private\n * @param {?Options} options\n * @returns {string} the currently configured tmp dir\n */\n\n\nfunction _getTmpDir(options) {\n  return path.resolve(_sanitizeName(options && options.tmpdir || os.tmpdir()));\n} // Install process exit listener\n\n\nprocess.addListener(EXIT, _garbageCollector);\n/**\n * Configuration options.\n *\n * @typedef {Object} Options\n * @property {?boolean} keep the temporary object (file or dir) will not be garbage collected\n * @property {?number} tries the number of tries before give up the name generation\n * @property (?int) mode the access mode, defaults are 0o700 for directories and 0o600 for files\n * @property {?string} template the \"mkstemp\" like filename template\n * @property {?string} name fixed name relative to tmpdir or the specified dir option\n * @property {?string} dir tmp directory relative to the root tmp directory in use\n * @property {?string} prefix prefix for the generated name\n * @property {?string} postfix postfix for the generated name\n * @property {?string} tmpdir the root tmp directory which overrides the os tmpdir\n * @property {?boolean} unsafeCleanup recursively removes the created temporary directory, even when it's not empty\n * @property {?boolean} detachDescriptor detaches the file descriptor, caller is responsible for closing the file, tmp will no longer try closing the file during garbage collection\n * @property {?boolean} discardDescriptor discards the file descriptor (closes file, fd is -1), tmp will no longer try closing the file during garbage collection\n */\n\n/**\n * @typedef {Object} FileSyncObject\n * @property {string} name the name of the file\n * @property {string} fd the file descriptor or -1 if the fd has been discarded\n * @property {fileCallback} removeCallback the callback function to remove the file\n */\n\n/**\n * @typedef {Object} DirSyncObject\n * @property {string} name the name of the directory\n * @property {fileCallback} removeCallback the callback function to remove the directory\n */\n\n/**\n * @callback tmpNameCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n */\n\n/**\n * @callback fileCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {number} fd the file descriptor or -1 if the fd had been discarded\n * @param {cleanupCallback} fn the cleanup callback function\n */\n\n/**\n * @callback fileCallbackSync\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {number} fd the file descriptor or -1 if the fd had been discarded\n * @param {cleanupCallbackSync} fn the cleanup callback function\n */\n\n/**\n * @callback dirCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {cleanupCallback} fn the cleanup callback function\n */\n\n/**\n * @callback dirCallbackSync\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {cleanupCallbackSync} fn the cleanup callback function\n */\n\n/**\n * Removes the temporary created file or directory.\n *\n * @callback cleanupCallback\n * @param {simpleCallback} [next] function to call whenever the tmp object needs to be removed\n */\n\n/**\n * Removes the temporary created file or directory.\n *\n * @callback cleanupCallbackSync\n */\n\n/**\n * Callback function for function composition.\n * @see {@link https://github.com/raszi/node-tmp/issues/57|raszi/node-tmp#57}\n *\n * @callback simpleCallback\n */\n// exporting all the needed methods\n// evaluate _getTmpDir() lazily, mainly for simplifying testing but it also will\n// allow users to reconfigure the temporary directory\n\nObject.defineProperty(module.exports, 'tmpdir', {\n  enumerable: true,\n  configurable: false,\n  get: function () {\n    return _getTmpDir();\n  }\n});\nmodule.exports.dir = dir;\nmodule.exports.dirSync = dirSync;\nmodule.exports.file = file;\nmodule.exports.fileSync = fileSync;\nmodule.exports.tmpName = tmpName;\nmodule.exports.tmpNameSync = tmpNameSync;\nmodule.exports.setGracefulCleanup = setGracefulCleanup;","map":{"version":3,"sources":["/home/alan/delivery_2/previously_on/client/node_modules/tmp/lib/tmp.js"],"names":["fs","require","os","path","crypto","_c","constants","rimraf","RANDOM_CHARS","TEMPLATE_PATTERN","DEFAULT_TRIES","CREATE_FLAGS","O_CREAT","O_EXCL","O_RDWR","IS_WIN32","platform","EBADF","errno","ENOENT","DIR_MODE","FILE_MODE","EXIT","_removeObjects","FN_RMDIR_SYNC","rmdirSync","bind","FN_RIMRAF_SYNC","sync","_gracefulCleanup","tmpName","options","callback","args","_parseArguments","opts","cb","_assertAndSanitizeOptions","err","tries","_getUniqueName","name","_generateTmpName","stat","Error","tmpNameSync","statSync","e","file","_tmpNameCreated","open","mode","_fileCreated","fd","discardDescriptor","close","_discardCallback","possibleErr","undefined","_prepareTmpFileRemoveCallback","discardOrDetachDescriptor","detachDescriptor","fileSync","openSync","closeSync","removeCallback","dir","mkdir","_dirCreated","_prepareTmpDirRemoveCallback","dirSync","mkdirSync","_removeFileAsync","fdPath","next","_handler","_isENOENT","unlink","_removeFileSync","rethrownException","_isEBADF","unlinkSync","removeCallbackSync","_prepareRemoveCallback","keep","unshift","removeFunction","unsafeCleanup","rmdir","removeFunctionSync","fileOrDirName","cleanupCallbackSync","called","_cleanupCallback","toRemove","index","indexOf","splice","_garbageCollector","length","_randomChars","howMany","value","rnd","randomBytes","pseudoRandomBytes","i","push","join","_isBlank","s","_isUndefined","trim","obj","actualOptions","key","Object","getOwnPropertyNames","tmpDir","tmpdir","template","replace","prefix","process","pid","postfix","_getTmpDir","_assertIsRelative","match","isNaN","relative","_resolvePath","_sanitizeName","sanitizedName","startsWith","resolve","option","isAbsolute","basename","resolvedPath","error","_isExpectedError","code","setGracefulCleanup","addListener","defineProperty","module","exports","enumerable","configurable","get"],"mappings":"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","sourcesContent":["/*!\n * Tmp\n *\n * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>\n *\n * MIT Licensed\n */\n\n/*\n * Module dependencies.\n */\nconst fs = require('fs');\nconst os = require('os');\nconst path = require('path');\nconst crypto = require('crypto');\nconst _c = { fs: fs.constants, os: os.constants };\nconst rimraf = require('rimraf');\n\n/*\n * The working inner variables.\n */\nconst\n  // the random characters to choose from\n  RANDOM_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n\n  TEMPLATE_PATTERN = /XXXXXX/,\n\n  DEFAULT_TRIES = 3,\n\n  CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR),\n\n  // constants are off on the windows platform and will not match the actual errno codes\n  IS_WIN32 = os.platform() === 'win32',\n  EBADF = _c.EBADF || _c.os.errno.EBADF,\n  ENOENT = _c.ENOENT || _c.os.errno.ENOENT,\n\n  DIR_MODE = 0o700 /* 448 */,\n  FILE_MODE = 0o600 /* 384 */,\n\n  EXIT = 'exit',\n\n  // this will hold the objects need to be removed on exit\n  _removeObjects = [],\n\n  // API change in fs.rmdirSync leads to error when passing in a second parameter, e.g. the callback\n  FN_RMDIR_SYNC = fs.rmdirSync.bind(fs),\n  FN_RIMRAF_SYNC = rimraf.sync;\n\nlet\n  _gracefulCleanup = false;\n\n/**\n * Gets a temporary file name.\n *\n * @param {(Options|tmpNameCallback)} options options or callback\n * @param {?tmpNameCallback} callback the callback function\n */\nfunction tmpName(options, callback) {\n  const\n    args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n\n  try {\n    _assertAndSanitizeOptions(opts);\n  } catch (err) {\n    return cb(err);\n  }\n\n  let tries = opts.tries;\n  (function _getUniqueName() {\n    try {\n      const name = _generateTmpName(opts);\n\n      // check whether the path exists then retry if needed\n      fs.stat(name, function (err) {\n        /* istanbul ignore else */\n        if (!err) {\n          /* istanbul ignore else */\n          if (tries-- > 0) return _getUniqueName();\n\n          return cb(new Error('Could not get a unique tmp filename, max tries reached ' + name));\n        }\n\n        cb(null, name);\n      });\n    } catch (err) {\n      cb(err);\n    }\n  }());\n}\n\n/**\n * Synchronous version of tmpName.\n *\n * @param {Object} options\n * @returns {string} the generated random name\n * @throws {Error} if the options are invalid or could not generate a filename\n */\nfunction tmpNameSync(options) {\n  const\n    args = _parseArguments(options),\n    opts = args[0];\n\n  _assertAndSanitizeOptions(opts);\n\n  let tries = opts.tries;\n  do {\n    const name = _generateTmpName(opts);\n    try {\n      fs.statSync(name);\n    } catch (e) {\n      return name;\n    }\n  } while (tries-- > 0);\n\n  throw new Error('Could not get a unique tmp filename, max tries reached');\n}\n\n/**\n * Creates and opens a temporary file.\n *\n * @param {(Options|null|undefined|fileCallback)} options the config options or the callback function or null or undefined\n * @param {?fileCallback} callback\n */\nfunction file(options, callback) {\n  const\n    args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n\n  // gets a temporary filename\n  tmpName(opts, function _tmpNameCreated(err, name) {\n    /* istanbul ignore else */\n    if (err) return cb(err);\n\n    // create and open the file\n    fs.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err, fd) {\n      /* istanbu ignore else */\n      if (err) return cb(err);\n\n      if (opts.discardDescriptor) {\n        return fs.close(fd, function _discardCallback(possibleErr) {\n          // the chance of getting an error on close here is rather low and might occur in the most edgiest cases only\n          return cb(possibleErr, name, undefined, _prepareTmpFileRemoveCallback(name, -1, opts, false));\n        });\n      } else {\n        // detachDescriptor passes the descriptor whereas discardDescriptor closes it, either way, we no longer care\n        // about the descriptor\n        const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;\n        cb(null, name, fd, _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, false));\n      }\n    });\n  });\n}\n\n/**\n * Synchronous version of file.\n *\n * @param {Options} options\n * @returns {FileSyncObject} object consists of name, fd and removeCallback\n * @throws {Error} if cannot create a file\n */\nfunction fileSync(options) {\n  const\n    args = _parseArguments(options),\n    opts = args[0];\n\n  const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;\n  const name = tmpNameSync(opts);\n  var fd = fs.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);\n  /* istanbul ignore else */\n  if (opts.discardDescriptor) {\n    fs.closeSync(fd);\n    fd = undefined;\n  }\n\n  return {\n    name: name,\n    fd: fd,\n    removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, true)\n  };\n}\n\n/**\n * Creates a temporary directory.\n *\n * @param {(Options|dirCallback)} options the options or the callback function\n * @param {?dirCallback} callback\n */\nfunction dir(options, callback) {\n  const\n    args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n\n  // gets a temporary filename\n  tmpName(opts, function _tmpNameCreated(err, name) {\n    /* istanbul ignore else */\n    if (err) return cb(err);\n\n    // create the directory\n    fs.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err) {\n      /* istanbul ignore else */\n      if (err) return cb(err);\n\n      cb(null, name, _prepareTmpDirRemoveCallback(name, opts, false));\n    });\n  });\n}\n\n/**\n * Synchronous version of dir.\n *\n * @param {Options} options\n * @returns {DirSyncObject} object consists of name and removeCallback\n * @throws {Error} if it cannot create a directory\n */\nfunction dirSync(options) {\n  const\n    args = _parseArguments(options),\n    opts = args[0];\n\n  const name = tmpNameSync(opts);\n  fs.mkdirSync(name, opts.mode || DIR_MODE);\n\n  return {\n    name: name,\n    removeCallback: _prepareTmpDirRemoveCallback(name, opts, true)\n  };\n}\n\n/**\n * Removes files asynchronously.\n *\n * @param {Object} fdPath\n * @param {Function} next\n * @private\n */\nfunction _removeFileAsync(fdPath, next) {\n  const _handler = function (err) {\n    if (err && !_isENOENT(err)) {\n      // reraise any unanticipated error\n      return next(err);\n    }\n    next();\n  };\n\n  if (0 <= fdPath[0])\n    fs.close(fdPath[0], function () {\n      fs.unlink(fdPath[1], _handler);\n    });\n  else fs.unlink(fdPath[1], _handler);\n}\n\n/**\n * Removes files synchronously.\n *\n * @param {Object} fdPath\n * @private\n */\nfunction _removeFileSync(fdPath) {\n  let rethrownException = null;\n  try {\n    if (0 <= fdPath[0]) fs.closeSync(fdPath[0]);\n  } catch (e) {\n    // reraise any unanticipated error\n    if (!_isEBADF(e) && !_isENOENT(e)) throw e;\n  } finally {\n    try {\n      fs.unlinkSync(fdPath[1]);\n    }\n    catch (e) {\n      // reraise any unanticipated error\n      if (!_isENOENT(e)) rethrownException = e;\n    }\n  }\n  if (rethrownException !== null) {\n    throw rethrownException;\n  }\n}\n\n/**\n * Prepares the callback for removal of the temporary file.\n *\n * Returns either a sync callback or a async callback depending on whether\n * fileSync or file was called, which is expressed by the sync parameter.\n *\n * @param {string} name the path of the file\n * @param {number} fd file descriptor\n * @param {Object} opts\n * @param {boolean} sync\n * @returns {fileCallback | fileCallbackSync}\n * @private\n */\nfunction _prepareTmpFileRemoveCallback(name, fd, opts, sync) {\n  const removeCallbackSync = _prepareRemoveCallback(_removeFileSync, [fd, name], sync);\n  const removeCallback = _prepareRemoveCallback(_removeFileAsync, [fd, name], sync, removeCallbackSync);\n\n  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);\n\n  return sync ? removeCallbackSync : removeCallback;\n}\n\n/**\n * Prepares the callback for removal of the temporary directory.\n *\n * Returns either a sync callback or a async callback depending on whether\n * tmpFileSync or tmpFile was called, which is expressed by the sync parameter.\n *\n * @param {string} name\n * @param {Object} opts\n * @param {boolean} sync\n * @returns {Function} the callback\n * @private\n */\nfunction _prepareTmpDirRemoveCallback(name, opts, sync) {\n  const removeFunction = opts.unsafeCleanup ? rimraf : fs.rmdir.bind(fs);\n  const removeFunctionSync = opts.unsafeCleanup ? FN_RIMRAF_SYNC : FN_RMDIR_SYNC;\n  const removeCallbackSync = _prepareRemoveCallback(removeFunctionSync, name, sync);\n  const removeCallback = _prepareRemoveCallback(removeFunction, name, sync, removeCallbackSync);\n  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);\n\n  return sync ? removeCallbackSync : removeCallback;\n}\n\n/**\n * Creates a guarded function wrapping the removeFunction call.\n *\n * The cleanup callback is save to be called multiple times.\n * Subsequent invocations will be ignored.\n *\n * @param {Function} removeFunction\n * @param {string} fileOrDirName\n * @param {boolean} sync\n * @param {cleanupCallbackSync?} cleanupCallbackSync\n * @returns {cleanupCallback | cleanupCallbackSync}\n * @private\n */\nfunction _prepareRemoveCallback(removeFunction, fileOrDirName, sync, cleanupCallbackSync) {\n  let called = false;\n\n  // if sync is true, the next parameter will be ignored\n  return function _cleanupCallback(next) {\n\n    /* istanbul ignore else */\n    if (!called) {\n      // remove cleanupCallback from cache\n      const toRemove = cleanupCallbackSync || _cleanupCallback;\n      const index = _removeObjects.indexOf(toRemove);\n      /* istanbul ignore else */\n      if (index >= 0) _removeObjects.splice(index, 1);\n\n      called = true;\n      if (sync || removeFunction === FN_RMDIR_SYNC || removeFunction === FN_RIMRAF_SYNC) {\n        return removeFunction(fileOrDirName);\n      } else {\n        return removeFunction(fileOrDirName, next || function() {});\n      }\n    }\n  };\n}\n\n/**\n * The garbage collector.\n *\n * @private\n */\nfunction _garbageCollector() {\n  /* istanbul ignore else */\n  if (!_gracefulCleanup) return;\n\n  // the function being called removes itself from _removeObjects,\n  // loop until _removeObjects is empty\n  while (_removeObjects.length) {\n    try {\n      _removeObjects[0]();\n    } catch (e) {\n      // already removed?\n    }\n  }\n}\n\n/**\n * Random name generator based on crypto.\n * Adapted from http://blog.tompawlak.org/how-to-generate-random-values-nodejs-javascript\n *\n * @param {number} howMany\n * @returns {string} the generated random name\n * @private\n */\nfunction _randomChars(howMany) {\n  let\n    value = [],\n    rnd = null;\n\n  // make sure that we do not fail because we ran out of entropy\n  try {\n    rnd = crypto.randomBytes(howMany);\n  } catch (e) {\n    rnd = crypto.pseudoRandomBytes(howMany);\n  }\n\n  for (var i = 0; i < howMany; i++) {\n    value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);\n  }\n\n  return value.join('');\n}\n\n/**\n * Helper which determines whether a string s is blank, that is undefined, or empty or null.\n *\n * @private\n * @param {string} s\n * @returns {Boolean} true whether the string s is blank, false otherwise\n */\nfunction _isBlank(s) {\n  return s === null || _isUndefined(s) || !s.trim();\n}\n\n/**\n * Checks whether the `obj` parameter is defined or not.\n *\n * @param {Object} obj\n * @returns {boolean} true if the object is undefined\n * @private\n */\nfunction _isUndefined(obj) {\n  return typeof obj === 'undefined';\n}\n\n/**\n * Parses the function arguments.\n *\n * This function helps to have optional arguments.\n *\n * @param {(Options|null|undefined|Function)} options\n * @param {?Function} callback\n * @returns {Array} parsed arguments\n * @private\n */\nfunction _parseArguments(options, callback) {\n  /* istanbul ignore else */\n  if (typeof options === 'function') {\n    return [{}, options];\n  }\n\n  /* istanbul ignore else */\n  if (_isUndefined(options)) {\n    return [{}, callback];\n  }\n\n  // copy options so we do not leak the changes we make internally\n  const actualOptions = {};\n  for (const key of Object.getOwnPropertyNames(options)) {\n    actualOptions[key] = options[key];\n  }\n\n  return [actualOptions, callback];\n}\n\n/**\n * Generates a new temporary name.\n *\n * @param {Object} opts\n * @returns {string} the new random name according to opts\n * @private\n */\nfunction _generateTmpName(opts) {\n\n  const tmpDir = opts.tmpdir;\n\n  /* istanbul ignore else */\n  if (!_isUndefined(opts.name))\n    return path.join(tmpDir, opts.dir, opts.name);\n\n  /* istanbul ignore else */\n  if (!_isUndefined(opts.template))\n    return path.join(tmpDir, opts.dir, opts.template).replace(TEMPLATE_PATTERN, _randomChars(6));\n\n  // prefix and postfix\n  const name = [\n    opts.prefix ? opts.prefix : 'tmp',\n    '-',\n    process.pid,\n    '-',\n    _randomChars(12),\n    opts.postfix ? '-' + opts.postfix : ''\n  ].join('');\n\n  return path.join(tmpDir, opts.dir, name);\n}\n\n/**\n * Asserts whether the specified options are valid, also sanitizes options and provides sane defaults for missing\n * options.\n *\n * @param {Options} options\n * @private\n */\nfunction _assertAndSanitizeOptions(options) {\n\n  options.tmpdir = _getTmpDir(options);\n\n  const tmpDir = options.tmpdir;\n\n  /* istanbul ignore else */\n  if (!_isUndefined(options.name))\n    _assertIsRelative(options.name, 'name', tmpDir);\n  /* istanbul ignore else */\n  if (!_isUndefined(options.dir))\n    _assertIsRelative(options.dir, 'dir', tmpDir);\n  /* istanbul ignore else */\n  if (!_isUndefined(options.template)) {\n    _assertIsRelative(options.template, 'template', tmpDir);\n    if (!options.template.match(TEMPLATE_PATTERN))\n      throw new Error(`Invalid template, found \"${options.template}\".`);\n  }\n  /* istanbul ignore else */\n  if (!_isUndefined(options.tries) && isNaN(options.tries) || options.tries < 0)\n    throw new Error(`Invalid tries, found \"${options.tries}\".`);\n\n  // if a name was specified we will try once\n  options.tries = _isUndefined(options.name) ? options.tries || DEFAULT_TRIES : 1;\n  options.keep = !!options.keep;\n  options.detachDescriptor = !!options.detachDescriptor;\n  options.discardDescriptor = !!options.discardDescriptor;\n  options.unsafeCleanup = !!options.unsafeCleanup;\n\n  // sanitize dir, also keep (multiple) blanks if the user, purportedly sane, requests us to\n  options.dir = _isUndefined(options.dir) ? '' : path.relative(tmpDir, _resolvePath(options.dir, tmpDir));\n  options.template = _isUndefined(options.template) ? undefined : path.relative(tmpDir, _resolvePath(options.template, tmpDir));\n  // sanitize further if template is relative to options.dir\n  options.template = _isBlank(options.template) ? undefined : path.relative(options.dir, options.template);\n\n  // for completeness' sake only, also keep (multiple) blanks if the user, purportedly sane, requests us to\n  options.name = _isUndefined(options.name) ? undefined : _sanitizeName(options.name);\n  options.prefix = _isUndefined(options.prefix) ? '' : options.prefix;\n  options.postfix = _isUndefined(options.postfix) ? '' : options.postfix;\n}\n\n/**\n * Resolve the specified path name in respect to tmpDir.\n *\n * The specified name might include relative path components, e.g. ../\n * so we need to resolve in order to be sure that is is located inside tmpDir\n *\n * @param name\n * @param tmpDir\n * @returns {string}\n * @private\n */\nfunction _resolvePath(name, tmpDir) {\n  const sanitizedName = _sanitizeName(name);\n  if (sanitizedName.startsWith(tmpDir)) {\n    return path.resolve(sanitizedName);\n  } else {\n    return path.resolve(path.join(tmpDir, sanitizedName));\n  }\n}\n\n/**\n * Sanitize the specified path name by removing all quote characters.\n *\n * @param name\n * @returns {string}\n * @private\n */\nfunction _sanitizeName(name) {\n  if (_isBlank(name)) {\n    return name;\n  }\n  return name.replace(/[\"']/g, '');\n}\n\n/**\n * Asserts whether specified name is relative to the specified tmpDir.\n *\n * @param {string} name\n * @param {string} option\n * @param {string} tmpDir\n * @throws {Error}\n * @private\n */\nfunction _assertIsRelative(name, option, tmpDir) {\n  if (option === 'name') {\n    // assert that name is not absolute and does not contain a path\n    if (path.isAbsolute(name))\n      throw new Error(`${option} option must not contain an absolute path, found \"${name}\".`);\n    // must not fail on valid .<name> or ..<name> or similar such constructs\n    let basename = path.basename(name);\n    if (basename === '..' || basename === '.' || basename !== name)\n      throw new Error(`${option} option must not contain a path, found \"${name}\".`);\n  }\n  else { // if (option === 'dir' || option === 'template') {\n    // assert that dir or template are relative to tmpDir\n    if (path.isAbsolute(name) && !name.startsWith(tmpDir)) {\n      throw new Error(`${option} option must be relative to \"${tmpDir}\", found \"${name}\".`);\n    }\n    let resolvedPath = _resolvePath(name, tmpDir);\n    if (!resolvedPath.startsWith(tmpDir))\n      throw new Error(`${option} option must be relative to \"${tmpDir}\", found \"${resolvedPath}\".`);\n  }\n}\n\n/**\n * Helper for testing against EBADF to compensate changes made to Node 7.x under Windows.\n *\n * @private\n */\nfunction _isEBADF(error) {\n  return _isExpectedError(error, -EBADF, 'EBADF');\n}\n\n/**\n * Helper for testing against ENOENT to compensate changes made to Node 7.x under Windows.\n *\n * @private\n */\nfunction _isENOENT(error) {\n  return _isExpectedError(error, -ENOENT, 'ENOENT');\n}\n\n/**\n * Helper to determine whether the expected error code matches the actual code and errno,\n * which will differ between the supported node versions.\n *\n * - Node >= 7.0:\n *   error.code {string}\n *   error.errno {number} any numerical value will be negated\n *\n * CAVEAT\n *\n * On windows, the errno for EBADF is -4083 but os.constants.errno.EBADF is different and we must assume that ENOENT\n * is no different here.\n *\n * @param {SystemError} error\n * @param {number} errno\n * @param {string} code\n * @private\n */\nfunction _isExpectedError(error, errno, code) {\n  return IS_WIN32 ? error.code === code : error.code === code && error.errno === errno;\n}\n\n/**\n * Sets the graceful cleanup.\n *\n * If graceful cleanup is set, tmp will remove all controlled temporary objects on process exit, otherwise the\n * temporary objects will remain in place, waiting to be cleaned up on system restart or otherwise scheduled temporary\n * object removals.\n */\nfunction setGracefulCleanup() {\n  _gracefulCleanup = true;\n}\n\n/**\n * Returns the currently configured tmp dir from os.tmpdir().\n *\n * @private\n * @param {?Options} options\n * @returns {string} the currently configured tmp dir\n */\nfunction _getTmpDir(options) {\n  return path.resolve(_sanitizeName(options && options.tmpdir || os.tmpdir()));\n}\n\n// Install process exit listener\nprocess.addListener(EXIT, _garbageCollector);\n\n/**\n * Configuration options.\n *\n * @typedef {Object} Options\n * @property {?boolean} keep the temporary object (file or dir) will not be garbage collected\n * @property {?number} tries the number of tries before give up the name generation\n * @property (?int) mode the access mode, defaults are 0o700 for directories and 0o600 for files\n * @property {?string} template the \"mkstemp\" like filename template\n * @property {?string} name fixed name relative to tmpdir or the specified dir option\n * @property {?string} dir tmp directory relative to the root tmp directory in use\n * @property {?string} prefix prefix for the generated name\n * @property {?string} postfix postfix for the generated name\n * @property {?string} tmpdir the root tmp directory which overrides the os tmpdir\n * @property {?boolean} unsafeCleanup recursively removes the created temporary directory, even when it's not empty\n * @property {?boolean} detachDescriptor detaches the file descriptor, caller is responsible for closing the file, tmp will no longer try closing the file during garbage collection\n * @property {?boolean} discardDescriptor discards the file descriptor (closes file, fd is -1), tmp will no longer try closing the file during garbage collection\n */\n\n/**\n * @typedef {Object} FileSyncObject\n * @property {string} name the name of the file\n * @property {string} fd the file descriptor or -1 if the fd has been discarded\n * @property {fileCallback} removeCallback the callback function to remove the file\n */\n\n/**\n * @typedef {Object} DirSyncObject\n * @property {string} name the name of the directory\n * @property {fileCallback} removeCallback the callback function to remove the directory\n */\n\n/**\n * @callback tmpNameCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n */\n\n/**\n * @callback fileCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {number} fd the file descriptor or -1 if the fd had been discarded\n * @param {cleanupCallback} fn the cleanup callback function\n */\n\n/**\n * @callback fileCallbackSync\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {number} fd the file descriptor or -1 if the fd had been discarded\n * @param {cleanupCallbackSync} fn the cleanup callback function\n */\n\n/**\n * @callback dirCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {cleanupCallback} fn the cleanup callback function\n */\n\n/**\n * @callback dirCallbackSync\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {cleanupCallbackSync} fn the cleanup callback function\n */\n\n/**\n * Removes the temporary created file or directory.\n *\n * @callback cleanupCallback\n * @param {simpleCallback} [next] function to call whenever the tmp object needs to be removed\n */\n\n/**\n * Removes the temporary created file or directory.\n *\n * @callback cleanupCallbackSync\n */\n\n/**\n * Callback function for function composition.\n * @see {@link https://github.com/raszi/node-tmp/issues/57|raszi/node-tmp#57}\n *\n * @callback simpleCallback\n */\n\n// exporting all the needed methods\n\n// evaluate _getTmpDir() lazily, mainly for simplifying testing but it also will\n// allow users to reconfigure the temporary directory\nObject.defineProperty(module.exports, 'tmpdir', {\n  enumerable: true,\n  configurable: false,\n  get: function () {\n    return _getTmpDir();\n  }\n});\n\nmodule.exports.dir = dir;\nmodule.exports.dirSync = dirSync;\n\nmodule.exports.file = file;\nmodule.exports.fileSync = fileSync;\n\nmodule.exports.tmpName = tmpName;\nmodule.exports.tmpNameSync = tmpNameSync;\n\nmodule.exports.setGracefulCleanup = setGracefulCleanup;\n"]},"metadata":{},"sourceType":"script"}